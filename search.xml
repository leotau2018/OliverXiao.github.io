<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Seminar (4.2) Notes]]></title>
      <url>%2F2018%2F03%2F24%2Fseminar2%2F</url>
      <content type="text"><![CDATA[Notes for Seminar 4.2. Contents: A Probability Path Chapter 2-3 Lecturers: Jian &amp; Due Chapter 3. Random variables, elements and measurable mapsImportant Definitions** Random elements Measurable maps Random variable /vector /sequence / function /measure Common Notations** $[X \in A’]$ $P \circ X^{-1} $ $X \in B / B’, $ for measurable spaces $(\Omega,B),(\Omega’, B’)$ Useful Properties, Propositions and Corollaries**(Proofs are needed and important) Properties of inverse maps Propositions related to inverse maps [Prop. 3.1.1] If $B’$ is a $\sigma$-field, then $X^{-1}(B’)$ is a $\sigma$-field; [Prop. 3.1.2] $X^{-1}(\sigma(C’))= \sigma( X^{-1}(C’))$ Propositions to test for measurable maps [Prop. 3.2.1] $X: (\Omega, B) \rightarrow (\Omega’, B’)$ is measurable iff $X^{-1}(C’) \subset B$, when $B’= \sigma(C’)$ [Corollary 3.2.1] Situation when $\Omega’=R,B’= B(R)$ [Prop. 3.2.2] On metric spaces, continuity can lead to measurability. [Corollary 3.2.2] $g(X)$ is a random variable when: $g: R^k \rightarrow R , g\in B(R^k)/B(R)$, and $X$ is a random vector. examples of g [Prop. 3.2.4] The relationship between random vector and its corresponding random variables. Propositions for measurability and limits [Prop. 3.2.6] Limits applied to sequences of measurable functions are measurable. Proposition for $\sigma$-field generated by random variables [Prop. 3.3.1]​​​​​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seminar (3.25) Notes]]></title>
      <url>%2F2018%2F03%2F24%2Fseminar1%2F</url>
      <content type="text"><![CDATA[Notes for Seminar 3.25. Contents: A Probability Path Chapter 1-2 Lecturers: Tesi &amp; Jian Chapter 1. Sets and Events1.1 Core Classic Theorems in Probability and Statistics The Law of Large Numbers (LLN) Central Limit Theorem (CLT) Martingale Convergence Theorems and Optional Stopping 1.2 Basic Set Theory Notation Sample space $\Omega$ The power set of $\Omega$: $\cal{P}(\Omega)$ Subsets $A, B$ Collections of subsets $\cal{A, B}$ An individual element of $\Omega$: $\omega\in \Omega$ The set operations: Complementation; Intersection; Union; Difference; Symmetric difference Arbitrary index sets Relations between sets: Containment; Equality Simple connections between the set operations Indicator Functions 1.3 Limits of Sets $\lim\inf$, $\lim \sup$, $\lim$ Lemma 1.3.1 1.4 Monotone Sequences Proposition 1.4.1 Serveral assertions on Page 10 that provide additional parallels between sets and functionsand further illustrate the algebraic properties of sets. 1.5 Set Operations and Closure Closure: closed under one of the set operations 1-8 listed in Page 11 Field: A field is a non-empty class of subsets of $\Omega$ closed under finite union, finite intersection and complements. A synonym for field is algebra. $\sigma$-field: A $\sigma$-field is a non-empty class of subsets of $\Omega$ closed under countable union, countable intersection and complements. A synonym for $\sigma$-field is $\sigma$-algebra. Examples: A field that is not a $\sigma$-field. 1.6 The $\sigma$-field Generated by a Given Class $\cal{C}$Core: $\sigma$-fields cannot always be constructed by a countable set of operations on simple sets. Sometimes only abstraction works. We should discuss how to guarantee a desired or-field exists Corollary 1.6.1 The intersection of $\sigma$-fields is a $\sigma$-field. Definition 1.6.1 $\sigma(\cal{C})$ Proposition 1.6.1 Given a class $\cal{C}$ of subsets of $\Omega$, there is a unique minimal $\sigma$-field containing $\cal{C}$. 1.7 Borel Sets on the Real Line A Borel set is any set in a topological space that can be formed from open sets (or, equivalently, from closed sets) through the operations of countable union, countable intersection, and relative complement. For a topological space $X$, the collection of all Borel sets on $X$ forms a $\sigma$-algebra, known as the Borel algebra or Borel σ-algebra. The Borel algebra on $X$ is the smallest $\sigma$-algebra containing all open sets (or, equivalently, all closed sets). $\cal{B}(\Bbb{R})$ 1.8 Comparing Borel SetsTheorem 1.8.1: verify $\cal{B}((0,1]) = \cal{B}(\Bbb{R})\bigcap (0,1]​$ Chapter 2 Probability Spaces2.1 Basic Definitions and Properties A probability space is a triple $(\Omega, \cal{B}, P)$ $\Omega$ is the sample space corresponding to outcomes of some (perhaps hypo­thetical) experiment. $\cal{B}$ is the $\sigma$-algebra of subsets of $\Omega$. These subsets are called events. $P$ is a probability measure; that is, $P$ is a function with domain $\cal{B}$ and range $[0,1]$ such that $P(A) &gt; 0$ for all $A \in \cal{B}$. $P$ is $\sigma$-additive $P(\Omega)=1$ Some simple consequences of the definition of a probability measure $P$. Continuity More continuity and Fatou’s lemma $pdF$ &hArr; $P$ 2.2 More on Closure StructureThe minimal structure $\cal{S}$ generated by a class $\cal{C}$, which is denoted by $\cal{S}(\cal{C})$ Two equivalent postulates of $\lambda$-system $Dynkin’s theorem$ A significant application of it is that a probability measure on $\Bbb{R}$ is uniquely determined by its $df$. Proof: Proposition 2.2.3 2.3 Two Constructions Discrete models Coin tossing $N$ times 2.4 Constructions of Probability SpacesQuestion: How to construct a probability space when the sample space $\Omega$ is uncountable?General method: Start with a restricted, simple class of subsets $\cal{S}$ of $\Omega$ to which the assignments of probabilities is natural. Then, extend it to $\sigma(\cal{S})$. Definition of $extension$, $additive$ and $\sigma$-$additive$ of set functions Semialgebra and two examples $Combo\ Extension\ Theorem$ $First\ Extension\ Theorem$: To extend a probability measure from $\cal{S}$ to $\cal{A}(\cal{S})$Proof: Make use of Lemma 2.4.1 to extend and show $P’$ is $\sigma$-additive $Second\ Extension\ Theorem$: To extend a probability measure from algebra to $\sigma$-algebra 2.5 Measure Construction Lebesgue Measure on $(0,1]$Define $\cal{S}$ by $\cal{S}={(a,b]:0\le a \le b \le 1}$, which is a semialgebra.Then, define the set function $\lambda :\cal{S}\mapsto [0,1]$ by $\lambda(\varnothing)=0, \lambda(a,b]=b-a$At last, we only have to show $\lambda$ is $\sigma$-additive Construction of a Probability measure on $\Bbb{R}$ with Given Distribution Function $F(x)$First, we construct a Borel subset of $(0,1]$ from a Borel subset of $\Bbb{R}$ by $\xi_{F}(A)={x\in (0,1]: F^{leftarrow}(x)\in A}$. Then, we can just make use of Lebesgue measure we construct before.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Probability Thoery Review]]></title>
      <url>%2F2018%2F02%2F02%2FProbability-Review%2F</url>
      <content type="text"><![CDATA[[The is my notes in preparation of my PhD Admission interview that record the structure of probability theory.] The subject of probability theory is the mathematical analysis of random events, that is, of those empirical phenomena which do not have deterministic regularity but possess some statistical regularity. Probability SpaceA probability space contains three basic elements: The Sample Space $\Omega$, which is the set of all sample points $\omega$ The $\sigma$ - algebra $\mathcal{F}$ of events, which is a family of $\Omega$ subsets satisfying: $\Omega \in \mathcal{F}$; If $A\in \mathcal{F}$, then $\bar{A}\in \mathcal{F}$; If $A_1, A_2, …, A_n, … \in \mathcal{F}$, then $\cup_{n=1}^{\infty}A_{n}\in\mathcal{F}$. $\mathcal{F}$ statisfying the above three hypotheses is termed as $\sigma$ - algebra in $\Omega$ ant the elements of $\mathcal{F}$ are also called the elements. The probability $P$, which is a real function defined on $\mathcal{F}$: $A\in\mathcal{F}\rightarrow P(A)$, satistisfying Non-negativity: $P(A)\geq 0, \forall A\in\mathcal{F}$; Normalization: $P(\Omega) = 1$; Countable Addititivity: If $A_1, …, A_n, ….$ are mutually disjoint events, then $$P(\sum_{n=1}^{\infty} A_n) = \sum_{n=1}^{\infty} P(A_n)$$. (P.S. The probability measure is continuous, deduced by the Countable Addititivity) In terms of measure theory, probability is a normed measure defined on a $\sigma$ - algebra. The triple $(\Omega, \mathcal{F}, P)$ is called a probability space. Random VariablesSuppose that $\xi(\omega)$ is a real function defined in a probability space $(\Omega, \mathcal{F}, P)$ and that for any Borel set $B$$$\xi^{-1}(B) := \{\omega: \xi(\omega) \in B \}$$Then we can say that $\xi$ is a random variable, and that $\{P(\xi(\omega)\in B)\} \in \mathcal{F}$, is a prabability distribution associated with $\xi$. The distribution function is a complete description of a random variable. In function theory, we call the function $\xi$ satistisfying the above definition to be measurable with respect to the $\sigma$ - algebra $\mathcal{F}$. Numerical Characteristics Mathematical Expectation Variance, Covariance, Correlation Coefficient, Moment ( Chebyshev’s Inequality: Assume that the random variable $\xi$ has variance, then it follows for any given $\varepsilon &gt; 0$ that $P(|\xi-E(\xi)|\geq \varepsilon) \leq \frac{Var(\xi)}{\varepsilon^2}$. ) Characteristic FunctionsGenerally speaking, the numerical characateristics cannot completely determine the distribution function of a random variable. The concept of characteristics function is introduced to completely determine the distribution function and possesses nice properties as well. Suppose $\xi$ is a real random variable, we call$$f(t) = E(e^{it\xi}), \quad -\infty &lt; t &lt; \infty$$ the characteristics function of $\xi$. Property $|f(t)|\leq f(0) = 1$, $f(-t)=\overline{f(t)}$ $f(t)$ is uniformly continuous on $(-\infty, \infty)$ $f(t)$ is nonnegative definite. Assume that $\xi_1, …, \xi_n$ are independent with characteristics functions $f_1(t), …, f_n(t)$ respectively. Let $\eta = \xi_1 + … + \xi_n$, then $f_{\eta}(t) = f_1(t)f_2(t)\cdots f_n(t)$. If $E(\xi^n)$ exists, then $f(t)$ is differentiable of $n$ order, and when $k\leq n$, $f^{(k)}(0)=i^{k}E(\xi^k)$. Let $\eta = a\xi + b$, where a, b are arbitrary constants. Then $f_{\eta}(t) = e^{ibt}f(at)$. Bochner-Khinchine Theorem The funtion $f(t)$ is characteristics function if and only if $f(t)$ is nonnegative definite, continuous and $f(0)=1$. Inverse Formula Suppose that $f(t)$ is a characteristic function correpsonding to distribution function $F(x)$. Let $x_1, x_2$ be two continuity points of $F(x)$, then$$F(x_2)- F(x_1) = \lim_{T\rightarrow \infty}\frac{1}{2\pi}\int_{-T}^{T}\frac{e^{-itx_1}- e^{-itx_2}}{it}f(t)dt$$ Theorem of Uniqueness A distribution function can be uniquely determined by its characteristic function. Inverse Fourier Transform Suppose that $f(t$ is a characteristic function and $\int_{-\infty}^{\infty}|f(t)| dt &lt; \infty$, then the derivative of the correpsonding distribution function $F(x)$ exits and it continuous. Moreover $$F’(x)= \frac{1}{2\pi}\int_{-\infty}^{\infty}e^{-itx}f(t)dt$$ Probability Limit Theorems—TO BE CONTINUED—]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用C++实现的简单的小游戏：Adventure]]></title>
      <url>%2F2017%2F04%2F04%2FOOPHW-3%2F</url>
      <content type="text"><![CDATA[这周，面向对象程序设计（Object Oriented Programming）留了一个有意思的C++的小游戏作业。游戏介绍如下： AdeventureStoryAdventure is a CLI game. The player has to explore in the castle with many levels and a lot of rooms. The task of the player is to find a room where the princess is prisoned and take her leave the castle. There are many types of rooms, and each type of room has different types of exits. Note that there’s a monster in one of the rooms, which the exact location is not able to be aware. But once the player meets a monster, the game is over. When the game starts, the player is at the lobby of the castle. Then the program shows information about the lobby：name of the room, how many exits are there, and names of all exits (e.g.: “east”, “south”, “up”), like: Welcome to the lobby. There are 3 exits as: east, west and up. Enter your command: The player then can input “go” followed by the name of one exit to enter the room connected with that door, like: go east The player goes into the room to the east. The program shows the information about that room, like what happened in the lobby just now. And the player may input command to choose another room. Once the player enters a room with a monster, the program shows a message and game over. Once the player enters the room of princess, the program shows a message about the princess, and the princess is going to leave with the player. The player then has to find their way out the castle. The only way to leave the castle is via the lobby.All printed messages and user input are in English to simplify the code. Requirement At least three different kinds of room; At least five rooms; The room with monster or princess is randomly set. 简单说，就是一个王子在城堡中救公主且不能碰到怪兽。由于自己是C++的初学者，所以写起来还是有些费劲，不过在写代码的过程中，自己还是收益很多的，主要由纠正了自己对OOP的认知，学习了如何搭建架构（画类图）。 终于明白了真正的OOP是可以做到main函数中只有2句话的！ 我的游戏中，设置了8个房间，类似2阶魔方的双层构造，怪兽和公主所在的房间随机。仍还在考虑如何将地图变得更加复杂，有想法的同学欢迎交流。 下面是游戏运行的截图： 运气不错，找了几次后就找到了公主，直接按照方向相反就可以回到大厅，成功逃脱城堡！ 总结 了解了OOP的精髓： 可以封装的尽量封装，虽然对于这次作业有过度封装的嫌疑（如Player类、Room类），但是这种封装方便游戏下一次的优化和更新。 STL中的vector, map的使用更加了解 学会了简单的makefile 这次写的makefile，作为一个Geek，是不能总在IDE中写程序的 12345678objs = Map.o Player.o Room.o Solution.o main.oCPPFLAGS = -std=c++14 install : $(objs) g++ -o adv $(objs)clean : rm $(objs) 改进游戏貌似过于简单，挺想增加一个难度和乐趣的，比如在某个房间里多加一把宝剑，可以干掉怪兽一次，但是怪兽可以无限次复活而且复活的房间随机。另外地图的确可以做的更复杂一些。 具体的代码可以参见我的Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写在大三下]]></title>
      <url>%2F2017%2F03%2F12%2Fjuniorthinking%2F</url>
      <content type="text"><![CDATA[Life is not a race. Even if life is a race, it is a race in which the process is more important than the result. 最近感觉同级的人们情绪都很紧张，自己也不例外，毕竟在这个人生中可能比高三还要重要的阶段，每个人都会在无数的可能前暗自发愁。 有朋友GPA不高，保不了研，成为了自习室的考研大军中的一员；有朋友为了争取最后的保研的机会，夜以继日地学习以在学期末取得好的成绩；出国党们，考着GT，刷着GPA，看着paper，做着实习…… 而我就是万千出国党中的一份子，背着可能一辈子也不会再用到的GRE单词，每天看着琦叔的励志鸡汤，每天单词、paper、codes充斥整个大脑。大概一星期前，刚开学的我，还踌躇满志，立志在这学期要拿得下GT，看得了paper，码得了代码，刷得了GPA。但现实总是残酷的，我发现我做不到6点起床背单词，做不到上课精神饱满，做不到一星期3篇paper的阅读…… 人在学期初，总是能极大地高估自己的潜力的。 于是在这个星期日，脑子和身子还是罢了工，昏昏沉沉睡了很久。 人醒了，总是能想通很多事。 其实，往往疲惫的感觉，更多地来源于自己和自己过不去。别人一天能背300个单词，而自己一天200个都很难背下来；别人能看数不尽的paper，甚至本科都能发得了paper，而自己却很多paper都看不懂……极大多数的疲惫感，来自于和别人的比较。 人总是会盯住别人的闪光点，认为自己一无是处，而这种一无是处的错觉就会给你的精神以及身体带来消极的影响。 所以最近我和许多学弟学妹交流，我说的最多的一句话就是：“大学中厉害的人太多了，如果你总是看着厉害的人而否定自己，你永远会止步不前，成为不了别人眼中厉害的人。” 写下这篇随笔，只是想在开学初警告自己，专注走自己的路，做到无怨无悔即是好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中的图模型实现]]></title>
      <url>%2F2017%2F03%2F06%2Fpython-graph%2F</url>
      <content type="text"><![CDATA[本文为本科课程《算法语言》的笔记，代码以及内容参考于Think Complexity, 2nd edition, Chapter 2 什么是图（Graph）？ 图是离散的（discrete）、有关系（interconnected）的元素系统的一种表示方法 一些名词： 节点（nodes）：表示系统中的元素（elements）［图论中有时叫顶点vertex］ 边（edges）：表示元素间的关系（interconnections） 有向图 （Directed graph） 无向图 （Undirected graph） 图论（Graph Theory） 图算法 （Graph Algorithms） Python的前置准备1234567891011121314151617# 这句话是非标准的python，用于ipthon或jupyter这样的系统中，表示绘图即刻自动展开。%matplotlib inline# 这里把全部Warning过滤掉了. import warningswarnings.filterwarnings('ignore')import matplotlib.pyplot as plt# networkx是专门处理网络、图等数据结构的类.import networkx as nximport numpy as np# 颜色一般是每两位十六进制数代表一个0~255的整数, 表示一个颜色从最浅到最深。# 次序一般是#RRGGBB，分别代表红色、绿色和蓝色。COLORS = ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462', '#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5','#ffed6f'] 有向图（Directed graph）下面使用networkx生成一个简单的表示人物关系的有向图，并画出 123456789# 生成一个有向图赋予GG = nx.DiGraph()# 给G添加节点G.add_node('Alice')G.add_node('Bob')G.add_node('Chuck')G.add_node('Oliver')G.nodes() [&apos;Bob&apos;, &apos;Chuck&apos;, &apos;Alice&apos;, &apos;Oliver&apos;] 123456789# 给G添加边G.add_edge('Alice', 'Bob')G.add_edge('Alice', 'Chuck')G.add_edge('Bob', 'Alice')G.add_edge('Bob', 'Chuck')G.add_edge('Oliver','Bob')# （‘Bob’,'Chunk'）是一个tupleG.edges() [(&apos;Bob&apos;, &apos;Chuck&apos;), (&apos;Bob&apos;, &apos;Alice&apos;), (&apos;Alice&apos;, &apos;Bob&apos;), (&apos;Alice&apos;, &apos;Chuck&apos;), (&apos;Oliver&apos;, &apos;Bob&apos;)] 利用nx.draw_circular画图 123456nx.draw_circular(G, node_color=COLORS[0], node_size=2000, with_labels=True)# 这个类似Matlab中的axis equal，x-y方向比例一致。plt.axis('equal') 无向图（Undirected graph）下面给出一个表示城市以及其距离的无向图 注： pos 是一个字典（dictionary）把key(城市)和其value(经纬度)建立映射 123456# 这里的数字是经纬度positionpos = dict(Albany=(-74, 43), Boston=(-71, 42), NYC=(-74, 41), Philly=(-75, 40))pos['Albany'] (-74, 43) 我们可以用 pos 的键值去给图加节点 注：调用的是nx.Graph，无向图。 12345G = nx.Graph()# 用字典批量加入节点G.add_nodes_from(pos)G.nodes() [&apos;Boston&apos;, &apos;NYC&apos;, &apos;Albany&apos;, &apos;Philly&apos;, &apos;HZ&apos;] drive_times 也是一个字典结构，将两个城市构成的元组tuple和开车时间建立映射。 12345678# key is a tupledrive_times = &#123;('Albany', 'Boston'): 3, ('Albany', 'NYC'): 4, ('Boston', 'NYC'): 4, ('NYC', 'Philly'): 2&#125;# 调用这个字典键值要注意drive_times[('Albany', 'Boston')] 3 我们可以用 drive_times 的key给G批量加入边 123# 用字典批量加入边G.add_edges_from(drive_times)G.edges() [(&apos;Boston&apos;, &apos;NYC&apos;), (&apos;Boston&apos;, &apos;Albany&apos;), (&apos;NYC&apos;, &apos;Albany&apos;), (&apos;NYC&apos;, &apos;Philly&apos;)] 这里，G中并没有存储各点的坐标和各边的权，因此绘图的时候重新从pos和drive_times中读取坐标和边权。也就是说这里G只存储了拓扑意义上的图，其他具体化的数据，要另外处理，并小心保持一致。 1234567891011# 这里's'表示方块，'o'表示小圆，'d'表示小菱形...nx.draw(G, pos, node_color=COLORS[1], node_shape='s', node_size=2500, with_labels=True)nx.draw_networkx_edge_labels(G, pos, edge_labels=drive_times)plt.axis('equal') 完全图（Complete graph）为了生成一个完全图, 我们需要写一个生成边的函数遍历所有的节点，这里使用Python的一个内置函数enumerate enumerate是Python内置函数，作用是枚举一个可以遍历对象（如字典、列表）中的全部元素，并给予编号。在C语言中，我们是通过下标遍历数组，但在Python中，遍历直接通过for ... in...完成了，如果这个时候你还想有下标，那么用enumerate同时返回下标和值。这里yield和return的区别是yield返回值但不会结束程序。所以返回的结果可能会形成一个list。 12345def all_pairs(nodes): for i, u in enumerate(nodes): for j, v in enumerate(nodes): if i &lt; j: yield u, v make_complete_graph 函数用来构建一个完全图。 123456def make_complete_graph(n): G = nx.Graph() nodes = range(n) G.add_nodes_from(nodes) G.add_edges_from(all_pairs(nodes)) return G 下面给出一个10节点的完全图的例子 12complete = make_complete_graph(10)len(complete.nodes()) 10 1234nx.draw_circular(complete, node_color=COLORS[2], node_size=1000, with_labels=True) neighbors 方法 返回一个节点的所有邻居的值组成的list 1complete.neighbors(0) #查看node 0的全部邻居 [1, 2, 3, 4, 5, 6, 7, 8, 9] 扩展: 画出一个5个节点的有向的完全图 1234567891011121314151617# Solution def all_directed_pairs(nodes): for i, u in enumerate(nodes): for j, v in enumerate(nodes): yield u, vdef make_complete_directed_graph(n): DG = nx.DiGraph() nodes = range(n) DG.add_nodes_from(nodes) DG.add_edges_from(all_directed_pairs(nodes)) return DGdirected_complete = make_complete_directed_graph(5)nx.draw_circular(directed_complete, node_color=COLORS[2], node_size=1000, with_labels=True) 随机图（Random graphs）随机图模型是由一个概率p来决定两node之间是否应该有edge。 函数flip 在分布区间p返回True，在1-p返回False。 1234from numpy.random import randomdef flip(p): return random() &lt; p random_pairs 是以概率 p 生成边的函数 这里enumerate返回一个List或类似容器的枚举，第一个返回值是枚举的序号，第二个是对应的元素。 yield 表示返回值，但不中断函数运行。所以会持续输出一个list或一个tuple。 12345def random_pairs(nodes, p): for i, u in enumerate(nodes): for j, v in enumerate(nodes): if i&lt;j and flip(p): yield u, v 123456# enumerate 函数用法举例# 直接抓到一个列表的顺序下标。L=['monday','tuesday','wendesday','thursday','friday','saturday','sunday']for (i,day) in enumerate(L): print(i) print(day) 0 monday 1 tuesday 2 wendesday 3 thursday 4 friday 5 saturday 6 sunday make_random_graph 用上面的函数构建ER-Graph，一种著名的随机图。 123456def make_random_graph(n, p): G = nx.Graph() nodes = range(n) G.add_nodes_from(nodes) G.add_edges_from(random_pairs(nodes, p)) return G 给个例子，10个nodes，连接概率0.3。 注意：每次运行都会生成不同的图。 1234random_graph = make_random_graph(10, 0.3)#看看有几条边。len(random_graph.edges()) 12 图画出来看看，注意之前要有matplotlib导入。 1234nx.draw_circular(random_graph, node_color=COLORS[3], node_size=1000, with_labels=True) 连通性（Connectivity）接下去可以检查graph的连通性： 12345678910# 这个函数从一个node(start)出发，遍历在graph G中全部能到达的node。def reachable_nodes(G, start): seen = set() #一个空集 stack = [start] #一个空栈 while stack: node = stack.pop() #顶部跳出一个node，注意第一次跳出的一定是start if node not in seen: #如果seen中没有 seen.add(node) #则加入seen stack.extend(G.neighbors(node)) #把刚加入的点的全部邻居推入栈 return seen 完全图任何一个node均可以到达其余全部nodes 1reachable_nodes(complete, 0) {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 但是随机图可不一定连通 1reachable_nodes(random_graph, 0) {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 可以使用这种方式可以检查一个图是否连通： 1234def is_connected(G): start = next(G.nodes_iter()) reachable = reachable_nodes(G, start) return len(reachable) == len(G) 完全图是连通的： 1is_connected(complete) True 但是如果小概率（p较小）的随机图，一般都是不连通的： 12random_graph = make_random_graph(10, 0.1)len(random_graph.edges()) 6 1is_connected(random_graph) False 拓展: 有向图的连通性 根据Wolfram网站(http://mathworld.wolfram.com/ConnectedDigraph.html)，提供了两种directed graph连通的定义。 一种称”弱连通”，如果在undirected的意义下是连通的。 而相应的“强连通”指的是在方向路径的意义下，任两点都是连通的。即不但1-&gt;2，还必须2-&gt;1。 我们写一个函数去检查强连通性 1234567891011121314151617181920def directed_reachable_nodes(G, start): seen = set() stack = [start] while stack: node = stack.pop() if node not in seen: seen.add(node) stack.extend(G.successors(node)) # 这里体现了方向， # 必须是下一个到达的点 return seendef digraph_is_connected(G): for start in G.nodes_iter(): #从任一个点出发 reachable = directed_reachable_nodes(G, start) #寻找能到达的点列 if len(reachable) &lt; len(G): #长度必须和G的最长路径一致 return False #有一个点做不到，就返回False return True #全部做到了才是True complete_digraph = make_complete_directed_graph(5)digraph_is_connected(complete_digraph) True 1len(complete_digraph) # diected graph的最长路径 5 连通概率 （Probability of connectivity）现在来估计ER-graph是连通的概率。 prob_connected 函数通过 n 和 p 产生一个graphs的序列，然后返回他们是连通的比率。这里相当与做试验，来统计结果。默认做100次试验。 1234567def prob_connected(n, p, iters=100): count = 0 for i in range(iters): random_graph = make_random_graph(n, p) if is_connected(random_graph): count += 1 return count/iters 下面令n=10,p=0.3做1000次试验。 12n = 10prob_connected(n, 0.3, iters=10000) 0.6513 据Erdos and Renyi的结论，10个nodes的相变点是0.23。也就是p大于0.23，则连通的概率迅速趋于1，否则，趋于0。 相变点的计算公式如下： 12pstar = np.log(n) / npstar 0.23025850929940458 我们把一个范围的p对应的连通概率画出来。范围是$10^{-1.3}$ ~ $10^0=1$，按$\log$分布取11个分点。这样取点我们能清楚看到相变点0.23附近的变化。 12ps = np.logspace(-1.3, 0, 11)ps array([ 0.05011872, 0.0676083 , 0.09120108, 0.12302688, 0.16595869, 0.22387211, 0.30199517, 0.40738028, 0.54954087, 0.74131024, 1. ]) 每个输入概率，检验1000次。先打出来看看。我们能看见在0.23附近，连通概率迅速从0跃迁至1。 1234ys = [prob_connected(n, p, 1000) for p in ps]for p, y in zip(ps, ys): print(p, y) 0.0501187233627 0.0 0.0676082975392 0.0 0.0912010839356 0.005 0.123026877081 0.014 0.165958690744 0.103 0.223872113857 0.317 0.30199517204 0.678 0.407380277804 0.902 0.549540873858 0.992 0.741310241301 1.0 1.0 1.0 下面将相变点更生动地画出来： 注：这个thinkplot非常接近matlab的plot的风格。下面的命令很容易理解。 123456import thinkplot # 书中提供的一个modulethinkplot.vlines([pstar], 0, 1, color='gray') #竖线thinkplot.plot(ps, ys)thinkplot.config(xlabel='p', ylabel='prob connected', xscale='log', xlim=[ps[0], ps[-1]])# ps[0]表示list ps中的第一个，ps[-1]表示最后一个。 对不同的n绘制图 1234567891011121314ns = [30, 100, 300]ps = np.logspace(-2.5, 0, 11)thinkplot.preplot(len(ns))for n in ns: pstar = np.log(n) / n thinkplot.vlines([pstar], 0, 1, color='gray') ys = [prob_connected(n, p) for p in ps] thinkplot.plot(ps, ys, label='n=%d' % n)thinkplot.config(xlabel='p', ylabel='prob connected', xscale='log', xlim=[ps[0], ps[-1]], loc='upper left') 当 n 增长的时候, 相变点变小且变换变得更陡峭。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[凸优化（二）：凸函数的基本概念]]></title>
      <url>%2F2017%2F02%2F10%2Fconvex-optimization2%2F</url>
      <content type="text"><![CDATA[凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的Convex Optimization，在本文主要介绍凸函数等基本概念。 在凸优化中，作为希望优化的目标函数，凸函数的性质的探究是极为重要的，下面给出凸函数的定义： 定义：若函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$的domain为凸集，且满足 $$\forall x,y \in \mathbf{dom} \ f, \theta\in[0,1],\ f(\theta x+(1-\theta)y)\leq \theta \ f(x)+(1-\theta)\ f(y)$$那么称函数$\ f\ $为凸函数 从定义可以看出，凸函数其实是定义在$\mathbf{R}^n$上的泛函，且任意两点的连线段在其两点间函数图像上方： 所以我们可以得到等价条件： 函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$为凸函数当且仅当$\forall x,u \in \mathbf{dom} \ f, \ g(t)=f(x+tv)$为凸函数，由于函数$\ g:\mathbf{R}\rightarrow\mathbf{R}$,因此我们可以通过对$\mathbf{R}$上的泛函的性质去判断函数的凸性。 严格凸的定义（Strictly convex）: 如果在凸函数的定义中，$\forall x\neq y$，不等号严格成立，即$$f(\theta x+(1-\theta)y)&lt; \theta \ f(x)+(1-\theta)\ f(y)$$则称函数$\ f\ $为严格凸函数 凸函数的延拓对于$\mathbf{dom} \ f\subset\mathbf{R}^n$的凸函数$\ f\ $，我们可以很自然地将其延拓至$\mathbf{R}^n$的全空间中：$$ \tilde{f}(x)=\{\begin{aligned} \ \ f(x) \quad &amp; ,x\in \mathbf{dom} \ f \\\infty \quad &amp; ,x\notin \mathbf{dom} \ f\end{aligned}\$$ $\tilde{f}:\mathbf{R}^n\rightarrow R\bigcup {\infty}$为$\ f \ $的延拓（extended-value extension） 凸集的指示函数：假设凸集$C\subset\mathbf{R}^n$，考虑集合$C$上的凸函数$I_C$满足$I_C(x)=0,\ \forall x\in C$，函数$I_C$的延拓$$\tilde{I}_C(x)=\{\begin{aligned} 0 &amp; \quad,x\in C \\ \infty &amp; \quad,x\notin C\end{aligned}\$$称为集合$C$的指示函数（Indicator function） 引入指示函数$I_C$后，我们可以将任意凸函数的延拓写成$\tilde{f}=f+\tilde{I}_C$ 一阶条件假设泛函$\ f\ $一阶可微（First-order differentiable），即其梯度$\nabla f$在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么$\ f\ $为凸函数当且仅当$\mathbf{dom} \ f\ $为凸集且$$\forall x,y \in \mathbf{dom} \ f\ ,\quad f(y)\geq f(x)+\nabla f(x)^T(y-x)$$其几何意义可以由下图表示：其一阶Taylor估计为该函数的全局下估计 对于严格凸泛函，那么条件改为$\quad \forall x\neq y, \quad f(y)&gt; f(x)+\nabla f(x)^T(y-x)$ 一阶条件的证明： 二阶条件假设泛函$\ f\ $二阶可微，即，其Hessian矩阵$\nabla^2 f$在在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么函数$\ f\ $为凸函数当且仅当$\mathbf{dom} \ f\ $为凸集，且其Hessian矩阵$\nabla^2 f$半正定： $$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f\geq 0$$ 二阶条件的证明：同一阶条件一样，Taylor展开至二阶即可证得 对于$\mathbf{R}$上的函数，二阶条件可以退化为$f’’(x)\geq 0$且$\mathbf{dom} \ f\ $为区间 二阶条件的几何解释为其函数图像在定义域中每点处均有向上的正弯曲（positive upward curvature） 同理可写出凹函数的二阶条件：假设泛函$\ f\ $二阶可微，即，其Hessian矩阵$\nabla^2 f$在在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么函数$\ f\ $为凹函数当且仅当$\mathbf{dom} \ f\ $为凸集，且其Hessian矩阵$\nabla^2 f$半正定： $$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f\leq 0$$ 一致凸的二阶充分条件：其Hessian矩阵$\nabla^2 f$正定，即$$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f&gt; 0$$该条件并不是必要条件：如$f(x)=x^4$是一致凸函数，但其二阶导函数$f’’(x)=12 x^2$在$x=0$处等于$0$ 凸函数举例 指数函数（Exponential） $$f(x)=e^{ax}$$ 幂函数 （Powers） $$f(x)=x^a, x\in R^{+}, a\geq 1 \ or \ a\leq 0$$ 负对数函数 （Negative logarithm） $$f(x)=-\ln(x)$$ 负熵函数（Negative entropy） $$f(x)=x\ln(x)$$ 范数函数 （Norms） $$f(x)=\Vert x\Vert$$ 最大值函数 （Max function） $$f(\vec{x})=\max\{x_1,\cdots,x_n\}$$ 指数线性函数 （Log-sum-exp）$$f(x)=\ln(e^{x_1}+\cdots+e^{x_n})$$指数线性函数可被作为可微（实际上，可解析）的函数近似逼近最大值函数$\max\{x_1,\cdots,x_n\}$，因为有如下不等式成立：$$\max\{x_1,\cdots,x_n\}\leq \ln(e^{x_1}+\cdots+e^{x_n})\leq \max\{x_1,\cdots,x_n\}+\log n, \quad \forall x\in\mathbf{R}^n$$且当$x_1=x_2=\cdots=x_n$时，第二个不等式是紧的 下水平集与上水平集函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$的下$\alpha$水平集（$\alpha-sublevel \ set$）定义如下:$$C_{\alpha}=\{x\in\mathbf{dom}\ f \mid f(x)\leq \alpha\}$$ 凸函数的$\alpha$分段集为凸集，这点是显而易见的，根据下面的不等式可以推得$$f(\theta x+(1-\theta)y)\leq \theta \ f(x)+(1-\theta)\ f(y)\leq \theta\alpha+(1-\theta)\alpha\leq\alpha$$ 同理可以定义上$\alpha$水平集（$\alpha -superlevel\ set$），对于凹函数，其上$\alpha$水平集为凹集 上镜图与亚图函数$\ f(x)$ 的图像：$\{(x,f(x))\mid x\in \mathbf{dom}\ f\}$ 函数的上镜图（Epigraph）定义为$$\mathbf{epi}\ f=\{(x,t)\mid x\in \mathbf{dom}\ f, t\geq f(x)\}$$ 同理可以定义函数的亚图（hypograph）：$$\mathbf{hypo}\ f=\{(x,t)\mid x\in \mathbf{dom}\ f, t\leq f(x)\}$$ 关于凸函数的很多结论可以通过上镜图来从几何意义上进行证明，如凸函数的一阶条件，我们可以通过如下的几何方法进行证明： Jensen不等式及其延伸凸函数定义中的最基本的不等式$$f(\theta x+(1-\theta)y)\leq \theta\ f(x)+ (1-\theta)\ f(y)$$有时又称Jensen不等式 该不等式很容易地可以延伸至$k$点的形式：如果函数$\ f$为凸函数，$x_1,x_2,\cdots,x_k$，$\theta_1,\theta_2,\cdots,\theta_k\geq 0$且$\sum_{i=1}^{k}\theta_i=1$，那么有$$f(\theta_1 x_1+\theta_2 x_2+\cdots+\theta_k x_k)\leq \theta_1 f(x_1)+\theta_2 f(x_2)+\cdots+\theta_k f(x_k)$$ 还可以延伸到无穷和与积分的形式，比如，如果$\forall x\in S\subset\mathbf{dom} \ f,\ p(x)\geq 0$，且$\int_{S}p(x)dx=1$，那么$$f\left(\int_{S}p(x)xdx \right)\leq \int_{S}f(x)p(x)dx$$ 更为一般的，我们可以在$\mathbf{dom} \ f$上定义概率测度。如果$x$是定义在$\mathbf{dom}\ f$上的随机变量且$\ f$为凸函数，那么我们有$$f(\mathbf{E} x)\leq\mathbf{E}f(x)$$ 许多著名的不等式都是由Jensen不等式在取特定的凸函数$\ f$下延伸出来的，如均值不等式、$H\ddot{o}lder$不等式 保凸算子 同凸集一样，我们也可以讨论保持凸性的算子，将凸函数映射到凸函数，下面介绍常见重要的几种保凸算子 凸函数的非负加权和（Nonnegative weighted sums） $$f=w_1 f_1+w_2 f_2+\cdots+w_m f_m$$ 同样我们可以推广到无限和与积分：如果$\forall y\in\mathcal{A},\ f(x,y)$对于$x$是凸的，且$\forall y\in\mathcal{A},\ w(y)\geq 0$，那么 $$g(x)=\int_{\mathcal{A}}w(y)f(x,y)dy$$是凸函数 凸函数和仿射函数的复合函数（Composition with an affine mapping） 假设$\ f:\mathbf{R}^n\rightarrow\mathbf{R}$是凸函数，$A \in \mathbf{R}^{n\times m}$，且 $b\in \mathbf{R}^n$，定义$g:\mathbf{R}^m\rightarrow \mathbf{R}$ $$ g(x) = f(Ax + b),\quad \mathbf{dom}\ g = \{x\mid Ax+b ∈ \mathbf{dom}\ f\}$$那么$\ g(x)$为凸函数；如果$\ f$为凹函数，则$\ g(x)$为凹函数 凸函数的逐点最大值、逐点上确界$$f(x)=\max(f_1(x),f_2(x),\cdots, f_m(x))$$ $$f(x)=\sup_{y\in A}g(x,y)$$ 这里可以用上镜图的方法去证明其的保凸性，如下图$$\mathbf{epi}\ g=\bigcap_{y\in\mathcal{A}}\mathbf{epi}\ f(\cdot,y)$$ 共轭函数最后我们给出共轭函数（conjugate function）的定义： 定义：假设$\ f: \mathbf{R}^n \rightarrow \mathbf{R}$， 函数$\ f$的共轭函数 $\ f^{*}: \mathbf{R}^n \rightarrow \mathbf{R}$定义为$$f^{*}(y)=\sup_{x\in\mathbf{dom}\ f} (y^Tx-f(x))$$ 显然，定义式的右端是关于$y$的仿射函数，对它们逐点求上确界，得到的函数$\ f^{*}(y)$一定是凸函数，因此共轭函数必为凸函数 共轭函数由来：凸函数的共轭函数的共轭函数是其本身 对共轭函数的理解：如果函数$\ f$可微，对于每一固定的$y$，在满足$\ f’(x)=y$的点$x$处差值最大，如图 Fenchel不等式由共轭函数的定义，可以得到Fenchel不等式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[凸优化（一）：凸集的基本概念]]></title>
      <url>%2F2017%2F02%2F06%2Fconvex-optimization1%2F</url>
      <content type="text"><![CDATA[凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的Convex Optimization，在本文主要介绍凸集等基本概念。 在凸优化中，凸集是重要的基本概念，为此，引入以下概念 直线的向量表示给定二维平面上两定点：$\mathbf{a}(u_1,v_1),\mathbf{b}(u_2,v_2)$，则直线AB可以表示为$$\vec{x}=\theta\cdot\vec{a}+(1-\theta)\cdot\vec{b},\ \theta\in R$$若将$\theta$的范围限制到$[0,1]$，则表示线段AB 几何体的向量表示以上的向量表示方法可以推广至高维： 三维平面：$\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\theta_3\cdot\vec{a_3}, \ \ \theta_1+\theta_2+\theta_3=1, \theta_1,\theta_2,\theta_3\in R$ 三角形： $\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\theta_3\cdot\vec{a_3}, \ \ \theta_1+\theta_2+\theta_3=1, \theta_1,\theta_2,\theta_3\in [0,1]$ 超平面： $\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\cdots+\theta_k\cdot\vec{a_k}, \ \ \theta_1+\theta_2+\cdots+\theta_k=1, \theta_1,\theta_2,\cdots,\theta_k\in R$ 超几何体：$\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\cdots+\theta_k\cdot\vec{a_k}, \ \ \theta_1+\theta_2+\cdots+\theta_k=1, \theta_1,\theta_2,\cdots,\theta_k\in [0,1]$ 仿射集以上的表示方法可以引入几何学中一个重要的概念，仿射集（Affine set）： 定义：通过集合$C$的任意两个不同点的直线仍在集合$C$内，则称集合$C$是仿射集 $$\forall x_1,x_2\in C,\forall \theta\in R, x=\theta\cdot x_1+(1-\theta)\cdot x_2\in C$$ 仿射集的例子： 直线、平面 超平面：$\{x|Ax=b\}$ 凸集下面可以引入凸集概念，其定义有两种形式，两种形式是等价的 两点定义：集合$C$内任意两点间的线段均在集合$C$内，则称集合$C$是凸集$$\forall x_1,x_2\in C, \forall\theta\in[0,1], x=\theta\cdot x_1+(1-\theta)\cdot x_2\in C$$ $k$点定义：$$\forall x_1, x_2, \cdots, x_k \in C, \forall \theta_{i}\in [0,1], \sum_{i=1}^{k}\theta_{i}=1, x=\sum_{i=1}^{k}\theta_{i} x_i \in C$$ 根据仿射集和凸集的定义，我们知道：仿射集一定是凸集 凸包定义：集合C的所有点的凸组合形成的集合，叫做集合$C$的凸包（Convex hull） $$\mathbf{conv} \ \ C =\{\sum_{i=1}^{k}\theta_{i}x_{i}|x_{i}\in C, \theta_i \geq 0, \sum_{i=1}^{k}\theta_i =1\}$$ 推论：集合凸包是能包含$C$的最小凸集 超平面和半空间 超平面（hyperplane）$$\{x\ | \ a^{T}x=b\}$$$a$是其法向量 半空间（halfspace）$$\{x\ | \ a^{T}x\leq b\}\quad\quad\{x\ | \ a^{T}x\geq b\}$$ 欧式球和椭球 欧式球$$B(x_c,r)=\{x \ |\ \Vert x-x_c\Vert_2 \leq r \}=\{x \ |(x-x_c)^{T}(x-x_c) \leq r^2 \}$$​ 椭球$$E=\{x\ | (x-x_c)^T P(x-x_c)\leq r^2\}, 其中P为对称正定阵$$ 范数球和范数锥我们可以将欧式空间的二范数进行推广，得到广义的范数几何体 范数球（Norm Ball） $$ B(x_c,r)=\{x \ |\ \Vert x-x_c\Vert \leq r \} $$ 范数锥（Norm Cone） $$ \{(x,t) \ |\ \Vert x\Vert \leq t \} $$ 多面体引入以上概念后，我们可以如下去定义多面体（polyhedron）： 定义：多面体是有限个半空间和超平面的交集，即$$\mathcal{P}=\{ a_j^Tx\leq b_j, j=1,2,\cdots,m,\ \ c_i^T x=d_i, i=1,2,\cdots,p \}$$ 仿射集(如超平面、直线)、射线、线段、半空间都是多面体 多面体是凸集 有界多面体叫多胞形（polytope） 保凸运算引入凸集的概念后，自然地想研究集合间的映射算子与凸集的关系，特别地是保持凸性的算子，即将凸集映射为凸集的算子，下面给出4个保凸算子（Operations that preserve convexity） 集合的交运算（Intersection）$$\bigcap_{\alpha\in\mathcal{A}}S_{\alpha}$$ 仿射变换（Affine functions）$$f(x)=Ax+b$$ 透视变换（Perspective functions） 定义：$$ P:\mathbf{R}^{n+1}\rightarrow\mathbf{R}^{n}, \ \mathbf{dom} \ P=\mathbf{R}^{n}\times R_{+}$$$$(x_1,x_2,\cdots,x_n,t)\rightarrow(\frac{x_1}{t},\frac{x_2}{t},\cdots,\frac{x_n}{t}), t&gt;0$$从代数角度，透视变换相当于对原向量进行标准化化使得最后一个分量值为1，并去掉了最后一个分量；从几何角度，三维平面内透视变换相当于小孔成像的原理，如下图所示 线性分式变换（投射变换）（Linear-fractional functions） 定义：线性分式函数是仿射变换和透视变换的复合变换 $假设仿射变换\ g:\mathbf{R}^{n}\rightarrow\mathbf{R}^{m+1}$$$ g(x)=\begin{bmatrix}A\\ c^{T}\end{bmatrix}x+\begin{bmatrix}b\\ d\end{bmatrix}$$$\ 其中A\in \mathbf{R}^{m\times n},b\in\mathbf{R}^{m},c\in\mathbf{R}^{n},d\in\mathbf{R}$ $那么\ f:\mathbf{R}^{n}\rightarrow\mathbf{R}^{m}定义为f=P \circ g，即$ $$f(x)=\frac{Ax+b}{c^Tx+d},\quad \mathbf{dom}\ f=\{x|c^Tx+d&gt;0\}$$ 投影理解（Projective Interpretation）: 我们可以将线性分式变换写成矩阵形式，记 $$Q=\left[\begin{matrix} A &amp; b\\ c^T &amp; d \end{matrix}\right]\in\mathbf{R}^{(m+1)\times(n+1)} $$将$\ Q\ $乘上$(x,1)$可以得到$\ Q(x,1)=(Ax+b,c^Tx+d)$，再通过对最后一个分量标准化得到$\ \left(\ f(x),1\ \right)\ $. 定义如下从$R^{n}$的元素到$R^{n+1}$中的集合的算子$$\mathcal{P}(x)=\{t\cdot(x,1)|t&gt;0\}$$，则线性分式变换$f$可以写作$$f(x)=\mathcal{P}^{-1}(Q\mathcal{P}(x))$$这是一个投影算子，下图给出一个例子 分割超平面定义：设$C$和$D$是两集合，若存在超平面$a^{T}x=b$使得，$$\forall x\in C,a^Tx\leq b\ 且\ \forall x\in D, a^Tx\geq b$$则称$\{x|a^Tx=b\}$为集合$C,D$的分割超平面（Separating hyperplane） 定理：两个不相交的凸集必定有分割超平面 分割超平面的构造：两集合最近两点连线的中垂面 最优分割超平面的构造（SVM：Support Vector Machine） 支撑超平面定义：设集合$C$，$x_0$为$C$边界上的点。若存在$a\neq0$, 满足对任意$x\in C$,都有$a^Tx\leq a^Tx_0$成立,则称超平面$\{x|a^Tx\leq a^Tx_0\}$为集合$C$在点$x_0$处的支撑超平面（Supporting hyperplane） 定理：凸集边界上任意一点，均存在支撑超平面；反之，若一个闭的非中空（内部点不为空）集合，在边界上的任意一点均存在支撑超平面，则必为凸集]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oliver's Notes 新开始]]></title>
      <url>%2F2017%2F01%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[历经各种磨难，终于将自己的blog用hexo搭载好，挂在了Github上。虽然其中很多配置并不是很懂，但是也初步了解其原理：将本地的静态网站放在Github的Personal Page作为自己的blog。 以前在wordpress.com上建站，发现.com没有MathJax插件，写不了数学公式，加载图片也甚是麻烦，故打算关闭原来的blog，开启新的Oliver’s Notes。 虽然我明白这个网站并没有什么人会去看，但是希望能督促自己多读点书，多写点东西。既然想做一个Geek，就要拿出一个Geek的样子。希望未来的我能一直坚持下去，不忘初心。 本站记录些学习笔记，生活感悟（吐槽）等，更新频率不定。]]></content>
    </entry>

    
  
  
</search>
