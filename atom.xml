<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oliver&#39;s Notes</title>
  <subtitle>Be truth seeker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-03T09:16:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Oliver Xiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Probability Thoery Review</title>
    <link href="http://yoursite.com/2018/02/02/Probability-Review/"/>
    <id>http://yoursite.com/2018/02/02/Probability-Review/</id>
    <published>2018-02-02T07:08:08.000Z</published>
    <updated>2018-02-03T09:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[The is my notes in preparation of my PhD Admission interview that record the structure of probability theory.]</p>
<p>The subject of probability theory is the mathematical analysis of random events, that is, of those empirical phenomena which do not have deterministic regularity but possess some statistical regularity.</p>
<a id="more"></a>
<hr>
<h3 id="Probability-Space"><a href="#Probability-Space" class="headerlink" title="Probability Space"></a>Probability Space</h3><p>A probability space contains three basic elements:</p>
<ul>
<li><p>The Sample Space $\Omega$,  which is the set of all sample points $\omega$</p>
</li>
<li><p>The $\sigma$ - algebra $\mathcal{F}$ of events, which is a family of $\Omega$ subsets satisfying:</p>
<ol>
<li>$\Omega \in \mathcal{F}$;</li>
<li>If $A\in \mathcal{F}$, then $\bar{A}\in \mathcal{F}$;</li>
<li>If $A_1, A_2, …, A_n, … \in \mathcal{F}$, then  $\cup_{n=1}^{\infty}A_{n}\in\mathcal{F}$.</li>
</ol>
<p>$\mathcal{F}$ statisfying the above three hypotheses is termed as $\sigma$ - algebra in $\Omega$ ant the elements of $\mathcal{F}$ are also called the elements.</p>
</li>
<li><p>The probability $P$, which is a real function defined on $\mathcal{F}$: $A\in\mathcal{F}\rightarrow P(A)$, satistisfying</p>
<ol>
<li>Non-negativity: $P(A)\geq 0,  \forall A\in\mathcal{F}$;</li>
<li>Normalization: $P(\Omega) = 1$;</li>
<li>Countable Addititivity: If $A_1, …, A_n, ….$ are mutually disjoint events, then $$P(\sum_{n=1}^{\infty} A_n) = \sum_{n=1}^{\infty} P(A_n)$$. (P.S. The probability measure is continuous, deduced by the  Countable Addititivity)</li>
</ol>
<p>In terms of measure theory, probability is a normed measure defined on a $\sigma$ - algebra.</p>
</li>
</ul>
<p>The triple $(\Omega, \mathcal{F}, P)$ is called a probability space.</p>
<hr>
<h3 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h3><p>Suppose that $\xi(\omega)$ is a real function defined in a probability space $(\Omega, \mathcal{F}, P)$ and that for any Borel set $B$<br>$$<br>\xi^{-1}(B) := \{\omega: \xi(\omega) \in B \}<br>$$<br>Then we can say that $\xi$ is a random variable, and that $\{P(\xi(\omega)\in B)\} \in \mathcal{F}$, is a prabability distribution associated with $\xi$.</p>
<p>The distribution function is a complete description of a random variable.</p>
<p>In function theory, we call the function $\xi$ satistisfying the above definition to be measurable with respect to the $\sigma$ - algebra $\mathcal{F}$.</p>
<hr>
<h3 id="Numerical-Characteristics"><a href="#Numerical-Characteristics" class="headerlink" title="Numerical Characteristics"></a>Numerical Characteristics</h3><ul>
<li>Mathematical Expectation</li>
<li>Variance, Covariance, Correlation Coefficient, Moment</li>
</ul>
<p>( <strong>Chebyshev’s Inequality</strong>: Assume that the random variable $\xi$ has variance, then it follows for any given $\varepsilon &gt; 0$ that $P(|\xi-E(\xi)|\geq \varepsilon) \leq \frac{Var(\xi)}{\varepsilon^2}$. )</p>
<hr>
<h3 id="Characteristic-Functions"><a href="#Characteristic-Functions" class="headerlink" title="Characteristic Functions"></a>Characteristic Functions</h3><p>Generally speaking, the numerical characateristics cannot completely determine the distribution function of a random variable. The concept of characteristics function is introduced to completely determine the distribution function and possesses nice properties as well.</p>
<p>Suppose $\xi$ is a real random variable, we call<br>$$<br>f(t) = E(e^{it\xi}), \quad -\infty &lt; t &lt; \infty<br>$$</p>
<p>the characteristics function of $\xi$.</p>
<ul>
<li><p>Property</p>
<ol>
<li>$|f(t)|\leq f(0) = 1$, $f(-t)=\overline{f(t)}$</li>
<li>$f(t)$ is uniformly continuous on $(-\infty, \infty)$</li>
<li>$f(t)$ is nonnegative definite.</li>
<li>Assume that $\xi_1, …, \xi_n$ are independent with characteristics functions $f_1(t), …, f_n(t)$ respectively. Let $\eta = \xi_1 + … + \xi_n$, then $f_{\eta}(t) = f_1(t)f_2(t)\cdots f_n(t)$.</li>
<li>If $E(\xi^n)$ exists, then $f(t)$ is differentiable of $n$ order, and when $k\leq n$, $f^{(k)}(0)=i^{k}E(\xi^k)$.</li>
<li>Let $\eta = a\xi + b$, where a, b are arbitrary constants. Then $f_{\eta}(t) = e^{ibt}f(at)$.</li>
</ol>
</li>
<li><p>Bochner-Khinchine Theorem</p>
<p>The funtion $f(t)$ is characteristics function if and only if $f(t)$ is nonnegative definite, continuous and $f(0)=1$.</p>
</li>
<li><p>Inverse Formula</p>
<p>Suppose that $f(t)$ is a characteristic function correpsonding to distribution function $F(x)$. Let $x_1, x_2$ be two continuity points of $F(x)$, then<br>$$<br>F(x_2)- F(x_1) = \lim_{T\rightarrow \infty}\frac{1}{2\pi}\int_{-T}^{T}\frac{e^{-itx_1}- e^{-itx_2}}{it}f(t)dt<br>$$</p>
</li>
<li><p>Theorem of Uniqueness</p>
<p>A distribution function  can be uniquely determined by its characteristic function.</p>
</li>
</ul>
<ul>
<li><p>Inverse Fourier Transform</p>
<p>Suppose that $f(t$ is a characteristic function and $\int_{-\infty}^{\infty}|f(t)| dt &lt; \infty$, then the derivative of the correpsonding distribution function $F(x)$ exits and it continuous. Moreover</p>
<p>$$<br>F’(x)= \frac{1}{2\pi}\int_{-\infty}^{\infty}e^{-itx}f(t)dt<br>$$</p>
</li>
</ul>
<hr>
<h3 id="Probability-Limit-Theorems"><a href="#Probability-Limit-Theorems" class="headerlink" title="Probability Limit Theorems"></a>Probability Limit Theorems</h3><p>—TO BE CONTINUED—</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[The is my notes in preparation of my PhD Admission interview that record the structure of probability theory.]&lt;/p&gt;
&lt;p&gt;The subject of probability theory is the mathematical analysis of random events, that is, of those empirical phenomena which do not have deterministic regularity but possess some statistical regularity.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>用C++实现的简单的小游戏：Adventure</title>
    <link href="http://yoursite.com/2017/04/04/OOPHW-3/"/>
    <id>http://yoursite.com/2017/04/04/OOPHW-3/</id>
    <published>2017-04-04T14:26:37.000Z</published>
    <updated>2017-04-05T11:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oky0w68xw.bkt.clouddn.com/oop3.png" alt=""></p>
<p>这周，面向对象程序设计（Object Oriented Programming）留了一个有意思的C++的小游戏作业。游戏介绍如下：</p>
<a id="more"></a>
<h2 id="Adeventure"><a href="#Adeventure" class="headerlink" title="Adeventure"></a>Adeventure</h2><h3 id="Story"><a href="#Story" class="headerlink" title="Story"></a>Story</h3><p>Adventure is a CLI game. The player has to explore in the castle with many levels and a lot of rooms. The task of the player is to find a room where the princess is prisoned and take her leave the castle. There are many types of rooms, and each type of room has different types of exits. Note that there’s a monster in one of the rooms, which the exact location is not able to be aware. But once the player meets a monster, the game is over.</p>
<p>When the game starts, the player is at the lobby of the castle. Then the program shows information about the lobby：name of the room, how many exits are there, and names of all exits (e.g.: “east”, “south”, “up”), like:</p>
<pre><code>Welcome to the lobby. There are 3 exits as: east, west and up.
Enter your command:
</code></pre><p>The player then can input “go” followed by the name of one exit to enter the room connected with that door, like:</p>
<pre><code>go east
</code></pre><p>The player goes into the room to the east. The program shows the information about that room, like what happened in the lobby just now. And the player may input command to choose another room.</p>
<p>Once the player enters a room with a monster, the program shows a message and game over. Once the player enters the room of princess, the program shows a message about the princess, and the princess is going to leave with the player. The player then has to find their way out the castle. The only way to leave the castle is via the lobby.<br>All printed messages and user input are in English to simplify the code.</p>
<h3 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h3><ol>
<li>At least three different kinds of room;</li>
<li>At least five rooms;</li>
<li>The room with monster or princess is randomly set.</li>
</ol>
<p>简单说，就是一个王子在城堡中救公主且不能碰到怪兽。由于自己是C++的初学者，所以写起来还是有些费劲，不过在写代码的过程中，自己还是收益很多的，主要由纠正了自己对OOP的认知，学习了如何搭建架构（画类图）。</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/Adventure%20copy.png" alt=""></p>
<p>终于明白了真正的OOP是可以做到main函数中只有2句话的！</p>
<p>我的游戏中，设置了8个房间，类似2阶魔方的双层构造，怪兽和公主所在的房间随机。仍还在考虑如何将地图变得更加复杂，有想法的同学欢迎交流。</p>
<p>下面是游戏运行的截图：</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/adventure.png" alt=""></p>
<p>运气不错，找了几次后就找到了公主，直接按照方向相反就可以回到大厅，成功逃脱城堡！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>了解了OOP的精髓：</p>
<p>可以封装的尽量封装，虽然对于这次作业有过度封装的嫌疑（如Player类、Room类），但是这种封装方便游戏下一次的优化和更新。</p>
</li>
<li><p>STL中的vector, map的使用更加了解</p>
</li>
</ol>
<ol>
<li><p>学会了简单的makefile</p>
<p>这次写的makefile，作为一个Geek，是不能总在IDE中写程序的</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">objs = Map.o Player.o Room.o Solution.o main.o</div><div class="line">CPPFLAGS = -std=c++14 </div><div class="line"></div><div class="line">install : $(objs)</div><div class="line">	g++ -o adv $(objs)</div><div class="line"></div><div class="line">clean :</div><div class="line">	rm $(objs)</div></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>游戏貌似过于简单，挺想增加一个难度和乐趣的，比如在某个房间里多加一把宝剑，可以干掉怪兽一次，但是怪兽可以无限次复活而且复活的房间随机。另外地图的确可以做的更复杂一些。</p>
<p>具体的代码可以参见我的Github</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oky0w68xw.bkt.clouddn.com/oop3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这周，面向对象程序设计（Object Oriented Programming）留了一个有意思的C++的小游戏作业。游戏介绍如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Codes" scheme="http://yoursite.com/categories/Codes/"/>
    
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>写在大三下</title>
    <link href="http://yoursite.com/2017/03/12/juniorthinking/"/>
    <id>http://yoursite.com/2017/03/12/juniorthinking/</id>
    <published>2017-03-12T15:25:22.000Z</published>
    <updated>2017-03-12T16:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Life is not a race. Even if life is a race, it is a race in which the process is more important than the result.</p>
</blockquote>
<p><img src="http://oky0w68xw.bkt.clouddn.com/sky.jpg" alt=""></p>
<p>最近感觉同级的人们情绪都很紧张，自己也不例外，毕竟在这个人生中可能比高三还要重要的阶段，每个人都会在无数的可能前暗自发愁。</p>
<p>有朋友GPA不高，保不了研，成为了自习室的考研大军中的一员；有朋友为了争取最后的保研的机会，夜以继日地学习以在学期末取得好的成绩；出国党们，考着GT，刷着GPA，看着paper，做着实习……</p>
<p>而我就是万千出国党中的一份子，背着可能一辈子也不会再用到的GRE单词，每天看着琦叔的励志鸡汤，每天单词、paper、codes充斥整个大脑。大概一星期前，刚开学的我，还踌躇满志，立志在这学期要拿得下GT，看得了paper，码得了代码，刷得了GPA。但现实总是残酷的，我发现我做不到6点起床背单词，做不到上课精神饱满，做不到一星期3篇paper的阅读……</p>
<blockquote>
<p>人在学期初，总是能极大地高估自己的潜力的。</p>
</blockquote>
<a id="more"></a>
<p>于是在这个星期日，脑子和身子还是罢了工，昏昏沉沉睡了很久。</p>
<blockquote>
<p>人醒了，总是能想通很多事。</p>
</blockquote>
<p>其实，往往疲惫的感觉，更多地来源于自己和自己过不去。别人一天能背300个单词，而自己一天200个都很难背下来；别人能看数不尽的paper，甚至本科都能发得了paper，而自己却很多paper都看不懂……极大多数的疲惫感，来自于和别人的比较。</p>
<blockquote>
<p>人总是会盯住别人的闪光点，认为自己一无是处，而这种一无是处的错觉就会给你的精神以及身体带来消极的影响。</p>
</blockquote>
<p>所以最近我和许多学弟学妹交流，我说的最多的一句话就是：“大学中厉害的人太多了，如果你总是看着厉害的人而否定自己，你永远会止步不前，成为不了别人眼中厉害的人。”</p>
<p>写下这篇随笔，只是想在开学初警告自己，专注走自己的路，做到无怨无悔即是好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Life is not a race. Even if life is a race, it is a race in which the process is more important than the result.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://oky0w68xw.bkt.clouddn.com/sky.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近感觉同级的人们情绪都很紧张，自己也不例外，毕竟在这个人生中可能比高三还要重要的阶段，每个人都会在无数的可能前暗自发愁。&lt;/p&gt;
&lt;p&gt;有朋友GPA不高，保不了研，成为了自习室的考研大军中的一员；有朋友为了争取最后的保研的机会，夜以继日地学习以在学期末取得好的成绩；出国党们，考着GT，刷着GPA，看着paper，做着实习……&lt;/p&gt;
&lt;p&gt;而我就是万千出国党中的一份子，背着可能一辈子也不会再用到的GRE单词，每天看着琦叔的励志鸡汤，每天单词、paper、codes充斥整个大脑。大概一星期前，刚开学的我，还踌躇满志，立志在这学期要拿得下GT，看得了paper，码得了代码，刷得了GPA。但现实总是残酷的，我发现我做不到6点起床背单词，做不到上课精神饱满，做不到一星期3篇paper的阅读……&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人在学期初，总是能极大地高估自己的潜力的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="吐槽" scheme="http://yoursite.com/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>Python中的图模型实现</title>
    <link href="http://yoursite.com/2017/03/06/python-graph/"/>
    <id>http://yoursite.com/2017/03/06/python-graph/</id>
    <published>2017-03-06T07:44:16.000Z</published>
    <updated>2017-03-06T18:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文为本科课程《算法语言》的笔记，代码以及内容参考于<a href="http://greenteapress.com/wp/complexity2" target="_blank" rel="external">Think Complexity, 2nd edition</a>, Chapter 2</p>
</blockquote>
<h3 id="什么是图（Graph）？"><a href="#什么是图（Graph）？" class="headerlink" title="什么是图（Graph）？"></a>什么是图（Graph）？</h3><p> 图是离散的（discrete）、有关系（interconnected）的元素系统的一种表示方法</p>
<p>一些名词：</p>
<ul>
<li>节点（nodes）：表示系统中的元素（elements）［图论中有时叫顶点vertex］</li>
<li>边（edges）：表示元素间的关系（interconnections）</li>
<li>有向图 （Directed graph）</li>
<li>无向图 （Undirected graph）</li>
<li>图论（Graph Theory）</li>
<li>图算法 （Graph Algorithms）</li>
</ul>
<hr>
<h3 id="Python的前置准备"><a href="#Python的前置准备" class="headerlink" title="Python的前置准备"></a>Python的前置准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这句话是非标准的python，用于ipthon或jupyter这样的系统中，表示绘图即刻自动展开。</span></div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="comment"># 这里把全部Warning过滤掉了. </span></div><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># networkx是专门处理网络、图等数据结构的类.</span></div><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 颜色一般是每两位十六进制数代表一个0~255的整数, 表示一个颜色从最浅到最深。</span></div><div class="line"><span class="comment"># 次序一般是#RRGGBB，分别代表红色、绿色和蓝色。</span></div><div class="line">COLORS = [<span class="string">'#8dd3c7'</span>,<span class="string">'#ffffb3'</span>,<span class="string">'#bebada'</span>,<span class="string">'#fb8072'</span>,<span class="string">'#80b1d3'</span>,<span class="string">'#fdb462'</span>,</div><div class="line">          <span class="string">'#b3de69'</span>,<span class="string">'#fccde5'</span>,<span class="string">'#d9d9d9'</span>,<span class="string">'#bc80bd'</span>,<span class="string">'#ccebc5'</span>,<span class="string">'#ffed6f'</span>]</div></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h3 id="有向图（Directed-graph）"><a href="#有向图（Directed-graph）" class="headerlink" title="有向图（Directed graph）"></a>有向图（Directed graph）</h3><p>下面使用<code>networkx</code>生成一个简单的表示人物关系的有向图，并画出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成一个有向图赋予G</span></div><div class="line">G = nx.DiGraph()</div><div class="line"></div><div class="line"><span class="comment"># 给G添加节点</span></div><div class="line">G.add_node(<span class="string">'Alice'</span>)</div><div class="line">G.add_node(<span class="string">'Bob'</span>)</div><div class="line">G.add_node(<span class="string">'Chuck'</span>)</div><div class="line">G.add_node(<span class="string">'Oliver'</span>)</div><div class="line">G.nodes()</div></pre></td></tr></table></figure>
<pre><code>[&apos;Bob&apos;, &apos;Chuck&apos;, &apos;Alice&apos;, &apos;Oliver&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 给G添加边</span></div><div class="line">G.add_edge(<span class="string">'Alice'</span>, <span class="string">'Bob'</span>)</div><div class="line">G.add_edge(<span class="string">'Alice'</span>, <span class="string">'Chuck'</span>)</div><div class="line">G.add_edge(<span class="string">'Bob'</span>, <span class="string">'Alice'</span>)</div><div class="line">G.add_edge(<span class="string">'Bob'</span>, <span class="string">'Chuck'</span>)</div><div class="line">G.add_edge(<span class="string">'Oliver'</span>,<span class="string">'Bob'</span>)</div><div class="line"></div><div class="line"><span class="comment"># （‘Bob’,'Chunk'）是一个tuple</span></div><div class="line">G.edges()</div></pre></td></tr></table></figure>
<pre><code>[(&apos;Bob&apos;, &apos;Chuck&apos;),
 (&apos;Bob&apos;, &apos;Alice&apos;),
 (&apos;Alice&apos;, &apos;Bob&apos;),
 (&apos;Alice&apos;, &apos;Chuck&apos;),
 (&apos;Oliver&apos;, &apos;Bob&apos;)]
</code></pre><p>利用<code>nx.draw_circular</code>画图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nx.draw_circular(G, </div><div class="line">                 node_color=COLORS[<span class="number">0</span>], </div><div class="line">                 node_size=<span class="number">2000</span>, </div><div class="line">                 with_labels=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># 这个类似Matlab中的axis equal，x-y方向比例一致。</span></div><div class="line">plt.axis(<span class="string">'equal'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_10_0.png" alt="png"></p>
<hr>
<h3 id="无向图（Undirected-graph）"><a href="#无向图（Undirected-graph）" class="headerlink" title="无向图（Undirected graph）"></a>无向图（Undirected graph）</h3><p>下面给出一个表示城市以及其距离的无向图</p>
<p>注： <code>pos</code> 是一个字典（dictionary）把key(城市)和其value(经纬度)建立映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里的数字是经纬度position</span></div><div class="line">pos = dict(Albany=(<span class="number">-74</span>, <span class="number">43</span>),</div><div class="line">          Boston=(<span class="number">-71</span>, <span class="number">42</span>),</div><div class="line">          NYC=(<span class="number">-74</span>, <span class="number">41</span>),</div><div class="line">          Philly=(<span class="number">-75</span>, <span class="number">40</span>))</div><div class="line">pos[<span class="string">'Albany'</span>]</div></pre></td></tr></table></figure>
<pre><code>(-74, 43)
</code></pre><p>我们可以用 <code>pos</code> 的键值去给图加节点</p>
<p>注：调用的是<code>nx.Graph</code>，无向图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">G = nx.Graph()</div><div class="line"></div><div class="line"><span class="comment"># 用字典批量加入节点</span></div><div class="line">G.add_nodes_from(pos)</div><div class="line">G.nodes()</div></pre></td></tr></table></figure>
<pre><code>[&apos;Boston&apos;, &apos;NYC&apos;, &apos;Albany&apos;, &apos;Philly&apos;, &apos;HZ&apos;]
</code></pre><p><code>drive_times</code> 也是一个字典结构，将两个城市构成的元组tuple和开车时间建立映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># key is a tuple</span></div><div class="line">drive_times = &#123;(<span class="string">'Albany'</span>, <span class="string">'Boston'</span>): <span class="number">3</span>,</div><div class="line">               (<span class="string">'Albany'</span>, <span class="string">'NYC'</span>): <span class="number">4</span>,</div><div class="line">               (<span class="string">'Boston'</span>, <span class="string">'NYC'</span>): <span class="number">4</span>,</div><div class="line">               (<span class="string">'NYC'</span>, <span class="string">'Philly'</span>): <span class="number">2</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># 调用这个字典键值要注意</span></div><div class="line">drive_times[(<span class="string">'Albany'</span>, <span class="string">'Boston'</span>)]</div></pre></td></tr></table></figure>
<pre><code>3
</code></pre><p>我们可以用 <code>drive_times</code> 的key给<code>G</code>批量加入边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用字典批量加入边</span></div><div class="line">G.add_edges_from(drive_times)</div><div class="line">G.edges()</div></pre></td></tr></table></figure>
<pre><code>[(&apos;Boston&apos;, &apos;NYC&apos;), (&apos;Boston&apos;, &apos;Albany&apos;), (&apos;NYC&apos;, &apos;Albany&apos;), (&apos;NYC&apos;, &apos;Philly&apos;)]
</code></pre><p>这里，<code>G</code>中并没有存储各点的坐标和各边的权，因此绘图的时候重新从<code>pos</code>和<code>drive_times</code>中读取坐标和边权。也就是说这里<code>G</code>只存储了拓扑意义上的图，其他具体化的数据，要另外处理，并小心保持一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里's'表示方块，'o'表示小圆，'d'表示小菱形...</span></div><div class="line">nx.draw(G, pos, </div><div class="line">        node_color=COLORS[<span class="number">1</span>], </div><div class="line">        node_shape=<span class="string">'s'</span>, </div><div class="line">        node_size=<span class="number">2500</span>, </div><div class="line">        with_labels=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">nx.draw_networkx_edge_labels(G, pos, </div><div class="line">                             edge_labels=drive_times)</div><div class="line"></div><div class="line">plt.axis(<span class="string">'equal'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_20_0.png" alt="png"></p>
<hr>
<h3 id="完全图（Complete-graph）"><a href="#完全图（Complete-graph）" class="headerlink" title="完全图（Complete graph）"></a>完全图（Complete graph）</h3><p>为了生成一个完全图, 我们需要写一个生成边的函数遍历所有的节点，这里使用Python的一个内置函数<code>enumerate</code></p>
<p><code>enumerate</code>是Python内置函数，作用是枚举一个可以遍历对象（如字典、列表）中的全部元素，并给予编号。在C语言中，我们是通过下标遍历数组，但在Python中，遍历直接通过<code>for ... in...</code>完成了，如果这个时候你还想有下标，那么用<code>enumerate</code>同时返回下标和值。这里<code>yield</code>和<code>return</code>的区别是<code>yield</code>返回值但不会结束程序。所以返回的结果可能会形成一个list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_pairs</span><span class="params">(nodes)</span>:</span></div><div class="line">    <span class="keyword">for</span> i, u <span class="keyword">in</span> enumerate(nodes):</div><div class="line">        <span class="keyword">for</span> j, v <span class="keyword">in</span> enumerate(nodes):</div><div class="line">            <span class="keyword">if</span> i &lt; j:</div><div class="line">                <span class="keyword">yield</span> u, v</div></pre></td></tr></table></figure>
<p><code>make_complete_graph</code> 函数用来构建一个完全图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_complete_graph</span><span class="params">(n)</span>:</span></div><div class="line">    G = nx.Graph()</div><div class="line">    nodes = range(n)</div><div class="line">    G.add_nodes_from(nodes)</div><div class="line">    G.add_edges_from(all_pairs(nodes))</div><div class="line">    <span class="keyword">return</span> G</div></pre></td></tr></table></figure>
<p>下面给出一个10节点的完全图的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">complete = make_complete_graph(<span class="number">10</span>)</div><div class="line">len(complete.nodes())</div></pre></td></tr></table></figure>
<pre><code>10
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nx.draw_circular(complete, </div><div class="line">                 node_color=COLORS[<span class="number">2</span>], </div><div class="line">                 node_size=<span class="number">1000</span>, </div><div class="line">                 with_labels=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_27_0.png" alt="png"></p>
<p> <code>neighbors</code> 方法 返回一个节点的所有邻居的值组成的list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">complete.neighbors(<span class="number">0</span>)   <span class="comment">#查看node 0的全部邻居</span></div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p><strong>扩展:</strong> 画出一个5个节点的有向的完全图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Solution </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_directed_pairs</span><span class="params">(nodes)</span>:</span></div><div class="line">    <span class="keyword">for</span> i, u <span class="keyword">in</span> enumerate(nodes):</div><div class="line">        <span class="keyword">for</span> j, v <span class="keyword">in</span> enumerate(nodes):</div><div class="line">            <span class="keyword">yield</span> u, v</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_complete_directed_graph</span><span class="params">(n)</span>:</span></div><div class="line">    DG = nx.DiGraph()</div><div class="line">    nodes = range(n)</div><div class="line">    DG.add_nodes_from(nodes)</div><div class="line">    DG.add_edges_from(all_directed_pairs(nodes))</div><div class="line">    <span class="keyword">return</span> DG</div><div class="line">directed_complete = make_complete_directed_graph(<span class="number">5</span>)</div><div class="line">nx.draw_circular(directed_complete, </div><div class="line">                 node_color=COLORS[<span class="number">2</span>], </div><div class="line">                 node_size=<span class="number">1000</span>, </div><div class="line">                 with_labels=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_31_0.png" alt="png"></p>
<hr>
<h3 id="随机图（Random-graphs）"><a href="#随机图（Random-graphs）" class="headerlink" title="随机图（Random graphs）"></a>随机图（Random graphs）</h3><p>随机图模型是由一个概率p来决定两node之间是否应该有edge。</p>
<p>函数<code>flip</code> 在分布区间<code>p</code>返回<code>True</code>，在<code>1-p</code>返回<code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip</span><span class="params">(p)</span>:</span></div><div class="line">    <span class="keyword">return</span> random() &lt; p</div></pre></td></tr></table></figure>
<p><code>random_pairs</code> 是以概率 <code>p</code> 生成边的函数 </p>
<p>这里<code>enumerate</code>返回一个List或类似容器的枚举，第一个返回值是枚举的序号，第二个是对应的元素。</p>
<p><code>yield</code> 表示返回值，但不中断函数运行。所以会持续输出一个list或一个tuple。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_pairs</span><span class="params">(nodes, p)</span>:</span></div><div class="line">    <span class="keyword">for</span> i, u <span class="keyword">in</span> enumerate(nodes):</div><div class="line">        <span class="keyword">for</span> j, v <span class="keyword">in</span> enumerate(nodes):</div><div class="line">            <span class="keyword">if</span> i&lt;j <span class="keyword">and</span> flip(p):</div><div class="line">                <span class="keyword">yield</span> u, v</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># enumerate 函数用法举例</span></div><div class="line"><span class="comment"># 直接抓到一个列表的顺序下标。</span></div><div class="line">L=[<span class="string">'monday'</span>,<span class="string">'tuesday'</span>,<span class="string">'wendesday'</span>,<span class="string">'thursday'</span>,<span class="string">'friday'</span>,<span class="string">'saturday'</span>,<span class="string">'sunday'</span>]</div><div class="line"><span class="keyword">for</span> (i,day) <span class="keyword">in</span> enumerate(L):</div><div class="line">    print(i)</div><div class="line">    print(day)</div></pre></td></tr></table></figure>
<pre><code>0
monday
1
tuesday
2
wendesday
3
thursday
4
friday
5
saturday
6
sunday
</code></pre><p><code>make_random_graph</code> 用上面的函数构建ER-Graph，一种著名的随机图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_graph</span><span class="params">(n, p)</span>:</span></div><div class="line">    G = nx.Graph()</div><div class="line">    nodes = range(n)</div><div class="line">    G.add_nodes_from(nodes)</div><div class="line">    G.add_edges_from(random_pairs(nodes, p))</div><div class="line">    <span class="keyword">return</span> G</div></pre></td></tr></table></figure>
<p>给个例子，10个nodes，连接概率0.3。</p>
<p>注意：<br>每次运行都会生成不同的图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">random_graph = make_random_graph(<span class="number">10</span>, <span class="number">0.3</span>)</div><div class="line"></div><div class="line"><span class="comment">#看看有几条边。</span></div><div class="line">len(random_graph.edges())</div></pre></td></tr></table></figure>
<pre><code>12
</code></pre><p>图画出来看看，注意之前要有<code>matplotlib</code>导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nx.draw_circular(random_graph, </div><div class="line">                 node_color=COLORS[<span class="number">3</span>], </div><div class="line">                 node_size=<span class="number">1000</span>, </div><div class="line">                 with_labels=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_42_0.png" alt="png"></p>
<hr>
<h3 id="连通性（Connectivity）"><a href="#连通性（Connectivity）" class="headerlink" title="连通性（Connectivity）"></a>连通性（Connectivity）</h3><p>接下去可以检查graph的连通性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这个函数从一个node(start)出发，遍历在graph G中全部能到达的node。</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reachable_nodes</span><span class="params">(G, start)</span>:</span></div><div class="line">    seen = set()   <span class="comment">#一个空集</span></div><div class="line">    stack = [start]   <span class="comment">#一个空栈</span></div><div class="line">    <span class="keyword">while</span> stack:</div><div class="line">        node = stack.pop()   <span class="comment">#顶部跳出一个node，注意第一次跳出的一定是start</span></div><div class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> seen:   <span class="comment">#如果seen中没有</span></div><div class="line">            seen.add(node)   <span class="comment">#则加入seen</span></div><div class="line">            stack.extend(G.neighbors(node))   <span class="comment">#把刚加入的点的全部邻居推入栈</span></div><div class="line">    <span class="keyword">return</span> seen</div></pre></td></tr></table></figure>
<p>完全图任何一个node均可以到达其余全部nodes</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reachable_nodes(complete, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
</code></pre><p>但是随机图可不一定连通</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reachable_nodes(random_graph, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
</code></pre><p>可以使用这种方式可以检查一个图是否连通：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(G)</span>:</span></div><div class="line">    start = next(G.nodes_iter())</div><div class="line">    reachable = reachable_nodes(G, start)</div><div class="line">    <span class="keyword">return</span> len(reachable) == len(G)</div></pre></td></tr></table></figure>
<p>完全图是连通的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">is_connected(complete)</div></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>但是如果小概率（p较小）的随机图，一般都是不连通的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">random_graph = make_random_graph(<span class="number">10</span>, <span class="number">0.1</span>)</div><div class="line">len(random_graph.edges())</div></pre></td></tr></table></figure>
<pre><code>6
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">is_connected(random_graph)</div></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p><strong>拓展:</strong> 有向图的连通性</p>
<p>根据Wolfram网站(<a href="http://mathworld.wolfram.com/ConnectedDigraph.html)，提供了两种directed" target="_blank" rel="external">http://mathworld.wolfram.com/ConnectedDigraph.html)，提供了两种directed</a> graph连通的定义。</p>
<ul>
<li><p>一种称”弱连通”，如果在undirected的意义下是连通的。</p>
</li>
<li><p>而相应的“强连通”指的是在方向路径的意义下，任两点都是连通的。即不但1-&gt;2，还必须2-&gt;1。</p>
</li>
</ul>
<p>我们写一个函数去检查强连通性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">directed_reachable_nodes</span><span class="params">(G, start)</span>:</span></div><div class="line">    seen = set()</div><div class="line">    stack = [start]</div><div class="line">    <span class="keyword">while</span> stack:</div><div class="line">        node = stack.pop()</div><div class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> seen:</div><div class="line">            seen.add(node)</div><div class="line">            stack.extend(G.successors(node))    <span class="comment"># 这里体现了方向，</span></div><div class="line">                                                <span class="comment"># 必须是下一个到达的点</span></div><div class="line">    <span class="keyword">return</span> seen</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">digraph_is_connected</span><span class="params">(G)</span>:</span></div><div class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> G.nodes_iter():   <span class="comment">#从任一个点出发</span></div><div class="line">        reachable = directed_reachable_nodes(G, start)   <span class="comment">#寻找能到达的点列</span></div><div class="line">        <span class="keyword">if</span> len(reachable) &lt; len(G):   <span class="comment">#长度必须和G的最长路径一致</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span>   <span class="comment">#有一个点做不到，就返回False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span>   <span class="comment">#全部做到了才是True</span></div><div class="line">        </div><div class="line">complete_digraph = make_complete_directed_graph(<span class="number">5</span>)</div><div class="line">digraph_is_connected(complete_digraph)</div></pre></td></tr></table></figure>
<pre><code>True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">len(complete_digraph)   <span class="comment"># diected graph的最长路径</span></div></pre></td></tr></table></figure>
<pre><code>5
</code></pre><hr>
<h3 id="连通概率-（Probability-of-connectivity）"><a href="#连通概率-（Probability-of-connectivity）" class="headerlink" title="连通概率 （Probability of connectivity）"></a>连通概率 （Probability of connectivity）</h3><p>现在来估计ER-graph是连通的概率。</p>
<p><code>prob_connected</code> 函数通过 <code>n</code> 和 <code>p</code> 产生一个graphs的序列，然后返回他们是连通的比率。这里相当与做试验，来统计结果。默认做100次试验。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prob_connected</span><span class="params">(n, p, iters=<span class="number">100</span>)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</div><div class="line">        random_graph = make_random_graph(n, p)</div><div class="line">        <span class="keyword">if</span> is_connected(random_graph):</div><div class="line">            count += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> count/iters</div></pre></td></tr></table></figure>
<p>下面令<code>n=10,p=0.3</code>做1000次试验。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">10</span></div><div class="line">prob_connected(n, <span class="number">0.3</span>, iters=<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<pre><code>0.6513
</code></pre><p>据Erdos and Renyi的结论，10个nodes的相变点是0.23。也就是p大于0.23，则连通的概率迅速趋于1，否则，趋于0。</p>
<p>相变点的计算公式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pstar = np.log(n) / n</div><div class="line">pstar</div></pre></td></tr></table></figure>
<pre><code>0.23025850929940458
</code></pre><p>我们把一个范围的p对应的连通概率画出来。范围是$10^{-1.3}$ ~ $10^0=1$，按$\log$分布取11个分点。这样取点我们能清楚看到相变点0.23附近的变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps = np.logspace(<span class="number">-1.3</span>, <span class="number">0</span>, <span class="number">11</span>)</div><div class="line">ps</div></pre></td></tr></table></figure>
<pre><code>array([ 0.05011872,  0.0676083 ,  0.09120108,  0.12302688,  0.16595869,
        0.22387211,  0.30199517,  0.40738028,  0.54954087,  0.74131024,  1.        ])
</code></pre><p>每个输入概率，检验1000次。先打出来看看。我们能看见在0.23附近，连通概率迅速从0跃迁至1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ys = [prob_connected(n, p, <span class="number">1000</span>) <span class="keyword">for</span> p <span class="keyword">in</span> ps]</div><div class="line"></div><div class="line"><span class="keyword">for</span> p, y <span class="keyword">in</span> zip(ps, ys):</div><div class="line">    print(p, y)</div></pre></td></tr></table></figure>
<pre><code>0.0501187233627 0.0
0.0676082975392 0.0
0.0912010839356 0.005
0.123026877081 0.014
0.165958690744 0.103
0.223872113857 0.317
0.30199517204 0.678
0.407380277804 0.902
0.549540873858 0.992
0.741310241301 1.0
1.0 1.0
</code></pre><p>下面将相变点更生动地画出来：</p>
<p>注：这个<code>thinkplot</code>非常接近matlab的plot的风格。下面的命令很容易理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thinkplot <span class="comment"># 书中提供的一个module</span></div><div class="line"></div><div class="line">thinkplot.vlines([pstar], <span class="number">0</span>, <span class="number">1</span>, color=<span class="string">'gray'</span>)   <span class="comment">#竖线</span></div><div class="line">thinkplot.plot(ps, ys)</div><div class="line">thinkplot.config(xlabel=<span class="string">'p'</span>, ylabel=<span class="string">'prob connected'</span>, xscale=<span class="string">'log'</span>, xlim=[ps[<span class="number">0</span>], ps[<span class="number">-1</span>]])</div><div class="line"><span class="comment"># ps[0]表示list ps中的第一个，ps[-1]表示最后一个。</span></div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_70_0.png" alt="png"></p>
<p>对不同的<code>n</code>绘制图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ns = [<span class="number">30</span>, <span class="number">100</span>, <span class="number">300</span>]</div><div class="line">ps = np.logspace(<span class="number">-2.5</span>, <span class="number">0</span>, <span class="number">11</span>)</div><div class="line"></div><div class="line">thinkplot.preplot(len(ns))</div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns:</div><div class="line">    pstar = np.log(n) / n</div><div class="line">    thinkplot.vlines([pstar], <span class="number">0</span>, <span class="number">1</span>, color=<span class="string">'gray'</span>)</div><div class="line"></div><div class="line">    ys = [prob_connected(n, p) <span class="keyword">for</span> p <span class="keyword">in</span> ps]</div><div class="line">    thinkplot.plot(ps, ys, label=<span class="string">'n=%d'</span> % n)</div><div class="line"></div><div class="line">thinkplot.config(xlabel=<span class="string">'p'</span>, ylabel=<span class="string">'prob connected'</span>,</div><div class="line">                 xscale=<span class="string">'log'</span>, xlim=[ps[<span class="number">0</span>], ps[<span class="number">-1</span>]],</div><div class="line">                 loc=<span class="string">'upper left'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://oky0w68xw.bkt.clouddn.com/output_72_0.png" alt="png"></p>
<p>当 <code>n</code> 增长的时候, 相变点变小且变换变得更陡峭。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为本科课程《算法语言》的笔记，代码以及内容参考于&lt;a href=&quot;http://greenteapress.com/wp/complexity2&quot;&gt;Think Complexity, 2nd edition&lt;/a&gt;, Chapter 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是图（Graph）？&quot;&gt;&lt;a href=&quot;#什么是图（Graph）？&quot; class=&quot;headerlink&quot; title=&quot;什么是图（Graph）？&quot;&gt;&lt;/a&gt;什么是图（Graph）？&lt;/h3&gt;&lt;p&gt; 图是离散的（discrete）、有关系（interconnected）的元素系统的一种表示方法&lt;/p&gt;
&lt;p&gt;一些名词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点（nodes）：表示系统中的元素（elements）［图论中有时叫顶点vertex］&lt;/li&gt;
&lt;li&gt;边（edges）：表示元素间的关系（interconnections）&lt;/li&gt;
&lt;li&gt;有向图 （Directed graph）&lt;/li&gt;
&lt;li&gt;无向图 （Undirected graph）&lt;/li&gt;
&lt;li&gt;图论（Graph Theory）&lt;/li&gt;
&lt;li&gt;图算法 （Graph Algorithms）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Python的前置准备&quot;&gt;&lt;a href=&quot;#Python的前置准备&quot; class=&quot;headerlink&quot; title=&quot;Python的前置准备&quot;&gt;&lt;/a&gt;Python的前置准备&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这句话是非标准的python，用于ipthon或jupyter这样的系统中，表示绘图即刻自动展开。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;%matplotlib inline&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这里把全部Warning过滤掉了. &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; warnings&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;warnings.filterwarnings(&lt;span class=&quot;string&quot;&gt;&#39;ignore&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# networkx是专门处理网络、图等数据结构的类.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; networkx &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; nx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 颜色一般是每两位十六进制数代表一个0~255的整数, 表示一个颜色从最浅到最深。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 次序一般是#RRGGBB，分别代表红色、绿色和蓝色。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;COLORS = [&lt;span class=&quot;string&quot;&gt;&#39;#8dd3c7&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#ffffb3&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#bebada&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#fb8072&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#80b1d3&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#fdb462&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;string&quot;&gt;&#39;#b3de69&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#fccde5&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#d9d9d9&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#bc80bd&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#ccebc5&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;#ffed6f&#39;&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="图模型" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="算法语言" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>凸优化（二）：凸函数的基本概念</title>
    <link href="http://yoursite.com/2017/02/10/convex-optimization2/"/>
    <id>http://yoursite.com/2017/02/10/convex-optimization2/</id>
    <published>2017-02-10T15:08:08.000Z</published>
    <updated>2017-03-07T11:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的<em>Convex Optimization</em>，在本文主要介绍凸函数等基本概念。</p>
</blockquote>
<p>在凸优化中，作为希望优化的目标函数，凸函数的性质的探究是极为重要的，下面给出凸函数的定义：</p>
<p> <strong>定义</strong>：若函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$的domain为凸集，且满足<br> $$\forall x,y \in \mathbf{dom} \ f, \theta\in[0,1],\  f(\theta x+(1-\theta)y)\leq \theta \ f(x)+(1-\theta)\ f(y)$$<br>那么称函数$\ f\ $为凸函数</p>
<a id="more"></a>
<p>从定义可以看出，凸函数其实是定义在$\mathbf{R}^n$上的泛函，且任意两点的连线段在其两点间函数图像上方：<br><img src="http://oky0w68xw.bkt.clouddn.com/chord.png" alt=""></p>
<p>所以我们可以得到等价条件：</p>
<p>函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$为凸函数当且仅当$\forall x,u \in \mathbf{dom} \ f, \ g(t)=f(x+tv)$为凸函数，由于函数$\ g:\mathbf{R}\rightarrow\mathbf{R}$,因此我们可以通过对$\mathbf{R}$上的泛函的性质去判断函数的凸性。</p>
<p><strong>严格凸的定义</strong>（Strictly convex）:</p>
<p>如果在凸函数的定义中，$\forall x\neq y$，不等号严格成立，即<br>$$f(\theta x+(1-\theta)y)&lt; \theta \ f(x)+(1-\theta)\ f(y)$$<br>则称函数$\ f\ $为严格凸函数</p>
<hr>
<h3 id="凸函数的延拓"><a href="#凸函数的延拓" class="headerlink" title="凸函数的延拓"></a>凸函数的延拓</h3><p>对于$\mathbf{dom} \ f\subset\mathbf{R}^n$的凸函数$\ f\ $，我们可以很自然地将其延拓至$\mathbf{R}^n$的全空间中：<br>$$ \tilde{f}(x)=\{<br>\begin{aligned}<br> \ \  f(x) \quad &amp; ,x\in \mathbf{dom} \ f \\<br>\infty \quad &amp;  ,x\notin \mathbf{dom} \ f<br>\end{aligned}<br>\<br>$$</p>
<p>$\tilde{f}:\mathbf{R}^n\rightarrow R\bigcup {\infty}$为$\ f \ $的延拓（extended-value extension）</p>
<blockquote>
<p><strong>凸集的指示函数</strong>：假设凸集$C\subset\mathbf{R}^n$，考虑集合$C$上的凸函数$I_C$满足$I_C(x)=0,\ \forall x\in C$，函数$I_C$的延拓<br>$$\tilde{I}_C(x)=\{<br>\begin{aligned}<br>    0  &amp; \quad,x\in C \\<br>  \infty  &amp; \quad,x\notin C<br>\end{aligned}<br>\<br>$$<br>称为集合$C$的指示函数（Indicator function）</p>
</blockquote>
<p>引入指示函数$I_C$后，我们可以将任意凸函数的延拓写成$\tilde{f}=f+\tilde{I}_C$</p>
<hr>
<h3 id="一阶条件"><a href="#一阶条件" class="headerlink" title="一阶条件"></a>一阶条件</h3><p>假设泛函$\ f\ $一阶可微（First-order differentiable），即其梯度$\nabla f$在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么$\ f\ $为凸函数当且仅当$\mathbf{dom} \ f\ $为凸集且<br>$$\forall x,y \in \mathbf{dom} \ f\ ,\quad  f(y)\geq f(x)+\nabla f(x)^T(y-x)$$<br>其几何意义可以由下图表示：其一阶Taylor估计为该函数的全局<strong>下</strong>估计<br><img src="http://oky0w68xw.bkt.clouddn.com/first-order.png" alt=""></p>
<p>对于严格凸泛函，那么条件改为$\quad \forall x\neq y, \quad f(y)&gt; f(x)+\nabla f(x)^T(y-x)$</p>
<p><strong>一阶条件的证明</strong>：</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/proof1.png" alt=""></p>
<hr>
<h3 id="二阶条件"><a href="#二阶条件" class="headerlink" title="二阶条件"></a>二阶条件</h3><p>假设泛函$\ f\ $二阶可微，即，其Hessian矩阵$\nabla^2 f$在在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么函数$\ f\ $为凸函数当且仅当$\mathbf{dom} \ f\ $为凸集，且其Hessian矩阵$\nabla^2 f$半正定：<br> $$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f\geq 0$$</p>
<p><strong>二阶条件的证明</strong>：同一阶条件一样，Taylor展开至二阶即可证得</p>
<p>对于$\mathbf{R}$上的函数，二阶条件可以退化为$f’’(x)\geq 0$且$\mathbf{dom} \ f\ $为区间</p>
<p>二阶条件的几何解释为其函数图像在定义域中每点处均有向上的正弯曲（positive upward curvature）</p>
<p>同理可写出凹函数的二阶条件：<br>假设泛函$\ f\ $二阶可微，即，其Hessian矩阵$\nabla^2 f$在在$\mathbf{dom} \ f\ $的每点处存在，且$\mathbf{dom} \ f\ $为开集，那么函数$\ f\ $为凹函数当且仅当$\mathbf{dom} \ f\ $为凸集，且其Hessian矩阵$\nabla^2 f$半正定：<br> $$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f\leq 0$$</p>
<p>一致凸的二阶充分条件：其Hessian矩阵$\nabla^2 f$正定，即$$\forall x\in \mathbf{dom} \ f\ ,\quad\nabla^2 f&gt; 0$$<br>该条件并不是必要条件：如$f(x)=x^4$是一致凸函数，但其二阶导函数$f’’(x)=12 x^2$在$x=0$处等于$0$</p>
<hr>
<h3 id="凸函数举例"><a href="#凸函数举例" class="headerlink" title="凸函数举例"></a>凸函数举例</h3><ul>
<li>指数函数（Exponential）     $$f(x)=e^{ax}$$</li>
<li>幂函数 （Powers）    $$f(x)=x^a, x\in R^{+}, a\geq 1 \  or \ a\leq 0$$</li>
<li>负对数函数 （Negative logarithm）    $$f(x)=-\ln(x)$$</li>
<li>负熵函数（Negative entropy）    $$f(x)=x\ln(x)$$</li>
<li>范数函数    （Norms）    $$f(x)=\Vert x\Vert$$</li>
<li>最大值函数 （Max function）    $$f(\vec{x})=\max\{x_1,\cdots,x_n\}$$</li>
<li>指数线性函数  （Log-sum-exp）$$f(x)=\ln(e^{x_1}+\cdots+e^{x_n})$$<br>指数线性函数可被作为可微（实际上，可解析）的函数近似逼近最大值函数$\max\{x_1,\cdots,x_n\}$，因为有如下不等式成立：<br>$$\max\{x_1,\cdots,x_n\}\leq \ln(e^{x_1}+\cdots+e^{x_n})\leq \max\{x_1,\cdots,x_n\}+\log n, \quad \forall x\in\mathbf{R}^n$$<br>且当$x_1=x_2=\cdots=x_n$时，第二个不等式是紧的</li>
</ul>
<p><img src="http://oky0w68xw.bkt.clouddn.com/log-sum-exp.png" alt=""></p>
<hr>
<h3 id="下水平集与上水平集"><a href="#下水平集与上水平集" class="headerlink" title="下水平集与上水平集"></a>下水平集与上水平集</h3><p>函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$的下$\alpha$水平集（$\alpha-sublevel \ set$）定义如下:<br>$$C_{\alpha}=\{x\in\mathbf{dom}\ f \mid f(x)\leq \alpha\}$$</p>
<p>凸函数的$\alpha$分段集为凸集，这点是显而易见的，根据下面的不等式可以推得<br>$$f(\theta x+(1-\theta)y)\leq \theta \ f(x)+(1-\theta)\ f(y)\leq \theta\alpha+(1-\theta)\alpha\leq\alpha$$</p>
<p>同理可以定义上$\alpha$水平集（$\alpha -superlevel\ set$），对于凹函数，其上$\alpha$水平集为凹集</p>
<hr>
<h3 id="上镜图与亚图"><a href="#上镜图与亚图" class="headerlink" title="上镜图与亚图"></a>上镜图与亚图</h3><p>函数$\ f(x)$ 的图像：$\{(x,f(x))\mid x\in \mathbf{dom}\ f\}$</p>
<p>函数的上镜图（Epigraph）定义为<br>$$\mathbf{epi}\ f=\{(x,t)\mid x\in \mathbf{dom}\ f, t\geq f(x)\}$$</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/epigraph.png" alt=""></p>
<p>同理可以定义函数的亚图（hypograph）：<br>$$\mathbf{hypo}\ f=\{(x,t)\mid x\in \mathbf{dom}\ f, t\leq f(x)\}$$</p>
<p>关于凸函数的很多结论可以通过上镜图来从几何意义上进行证明，如凸函数的一阶条件，我们可以通过如下的几何方法进行证明：</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/epi.png" alt=""></p>
<hr>
<h3 id="Jensen不等式及其延伸"><a href="#Jensen不等式及其延伸" class="headerlink" title="Jensen不等式及其延伸"></a>Jensen不等式及其延伸</h3><p>凸函数定义中的最基本的不等式<br>$$f(\theta x+(1-\theta)y)\leq \theta\ f(x)+ (1-\theta)\ f(y)$$<br>有时又称Jensen不等式</p>
<p>该不等式很容易地可以延伸至$k$点的形式：如果函数$\ f$为凸函数，$x_1,x_2,\cdots,x_k$，$\theta_1,\theta_2,\cdots,\theta_k\geq 0$且$\sum_{i=1}^{k}\theta_i=1$，那么有<br>$$f(\theta_1 x_1+\theta_2 x_2+\cdots+\theta_k x_k)\leq \theta_1 f(x_1)+\theta_2 f(x_2)+\cdots+\theta_k f(x_k)$$</p>
<p>还可以延伸到无穷和与积分的形式，比如，如果$\forall x\in S\subset\mathbf{dom} \ f,\ p(x)\geq 0$，且$\int_{S}p(x)dx=1$，那么<br>$$f\left(\int_{S}p(x)xdx \right)\leq \int_{S}f(x)p(x)dx$$</p>
<p>更为一般的，我们可以在$\mathbf{dom} \ f$上定义概率测度。如果$x$是定义在$\mathbf{dom}\ f$上的随机变量且$\ f$为凸函数，那么我们有<br>$$f(\mathbf{E} x)\leq\mathbf{E}f(x)$$</p>
<p>许多著名的不等式都是由Jensen不等式在取特定的凸函数$\ f$下延伸出来的，如均值不等式、$H\ddot{o}lder$不等式</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/Holder.png" alt=""></p>
<hr>
<h3 id="保凸算子"><a href="#保凸算子" class="headerlink" title="保凸算子"></a>保凸算子</h3><p> 同凸集一样，我们也可以讨论保持凸性的算子，将凸函数映射到凸函数，下面介绍常见重要的几种保凸算子</p>
<ul>
<li><p><strong>凸函数的非负加权和</strong>（Nonnegative weighted sums）<br>  $$f=w_1 f_1+w_2 f_2+\cdots+w_m f_m$$<br>  同样我们可以推广到无限和与积分：如果$\forall y\in\mathcal{A},\ f(x,y)$对于$x$是凸的，且$\forall y\in\mathcal{A},\ w(y)\geq 0$，那么<br>  $$g(x)=\int_{\mathcal{A}}w(y)f(x,y)dy$$<br>是凸函数</p>
</li>
<li><p><strong>凸函数和仿射函数的复合函数</strong>（Composition with an affine mapping）</p>
</li>
</ul>
<p>假设$\ f:\mathbf{R}^n\rightarrow\mathbf{R}$是凸函数，$A \in \mathbf{R}^{n\times m}$，且 $b\in \mathbf{R}^n$，定义$g:\mathbf{R}^m\rightarrow \mathbf{R}$<br> $$ g(x) = f(Ax + b),\quad \mathbf{dom}\ g = \{x\mid Ax+b ∈ \mathbf{dom}\ f\}$$<br>那么$\ g(x)$为凸函数；如果$\ f$为凹函数，则$\ g(x)$为凹函数</p>
<ul>
<li><strong>凸函数的逐点最大值、逐点上确界</strong><br>$$f(x)=\max(f_1(x),f_2(x),\cdots, f_m(x))$$ $$f(x)=\sup_{y\in A}g(x,y)$$</li>
</ul>
<p>这里可以用上镜图的方法去证明其的保凸性，如下图<br>$$\mathbf{epi}\ g=\bigcap_{y\in\mathcal{A}}\mathbf{epi}\ f(\cdot,y)$$<br><img src="http://oky0w68xw.bkt.clouddn.com/epif.png" alt=""></p>
<hr>
<h3 id="共轭函数"><a href="#共轭函数" class="headerlink" title="共轭函数"></a>共轭函数</h3><p>最后我们给出共轭函数（conjugate function）的定义：</p>
<p><strong>定义</strong>：假设$\ f: \mathbf{R}^n \rightarrow \mathbf{R}$， 函数$\ f$的共轭函数 $\ f^{*}: \mathbf{R}^n \rightarrow \mathbf{R}$定义为<br>$$f^{*}(y)=\sup_{x\in\mathbf{dom}\ f} (y^Tx-f(x))$$</p>
<p>显然，定义式的右端是关于$y$的仿射函数，对它们逐点求上确界，得到的函数$\ f^{*}(y)$一定是凸函数，因此共轭函数必为凸函数</p>
<p><strong>共轭函数由来</strong>：凸函数的共轭函数的共轭函数是其本身</p>
<p><strong>对共轭函数的理解</strong>：如果函数$\ f$可微，对于每一固定的$y$，在满足$\ f’(x)=y$的点$x$处差值最大，如图<br><img src="http://oky0w68xw.bkt.clouddn.com/conj.png" alt=""></p>
<hr>
<h3 id="Fenchel不等式"><a href="#Fenchel不等式" class="headerlink" title="Fenchel不等式"></a>Fenchel不等式</h3><p>由共轭函数的定义，可以得到Fenchel不等式</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/Fenchel.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的&lt;em&gt;Convex Optimization&lt;/em&gt;，在本文主要介绍凸函数等基本概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在凸优化中，作为希望优化的目标函数，凸函数的性质的探究是极为重要的，下面给出凸函数的定义：&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;定义&lt;/strong&gt;：若函数$\ f:\mathbf{R}^n\rightarrow \mathbf{R}$的domain为凸集，且满足&lt;br&gt; $$\forall x,y \in \mathbf{dom} \ f, \theta\in[0,1],\  f(\theta x+(1-\theta)y)\leq \theta \ f(x)+(1-\theta)\ f(y)$$&lt;br&gt;那么称函数$\ f\ $为凸函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>凸优化（一）：凸集的基本概念</title>
    <link href="http://yoursite.com/2017/02/06/convex-optimization1/"/>
    <id>http://yoursite.com/2017/02/06/convex-optimization1/</id>
    <published>2017-02-06T15:12:58.000Z</published>
    <updated>2017-03-07T11:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的<em>Convex Optimization</em>，在本文主要介绍凸集等基本概念。</p>
</blockquote>
<p>在凸优化中，凸集是重要的基本概念，为此，引入以下概念</p>
<hr>
<h3 id="直线的向量表示"><a href="#直线的向量表示" class="headerlink" title="直线的向量表示"></a>直线的向量表示</h3><p>给定二维平面上两定点：$\mathbf{a}(u_1,v_1),\mathbf{b}(u_2,v_2)$，则直线AB可以表示为<br>$$\vec{x}=\theta\cdot\vec{a}+(1-\theta)\cdot\vec{b},\ \theta\in R$$<br>若将$\theta$的范围限制到$[0,1]$，则表示线段AB</p>
<a id="more"></a>
<hr>
<h3 id="几何体的向量表示"><a href="#几何体的向量表示" class="headerlink" title="几何体的向量表示"></a>几何体的向量表示</h3><p>以上的向量表示方法可以推广至高维：</p>
<ul>
<li>三维平面：$\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\theta_3\cdot\vec{a_3}, \ \ \theta_1+\theta_2+\theta_3=1, \theta_1,\theta_2,\theta_3\in R$</li>
<li>三角形： $\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\theta_3\cdot\vec{a_3}, \ \ \theta_1+\theta_2+\theta_3=1, \theta_1,\theta_2,\theta_3\in [0,1]$</li>
<li>超平面： $\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\cdots+\theta_k\cdot\vec{a_k}, \ \ \theta_1+\theta_2+\cdots+\theta_k=1, \theta_1,\theta_2,\cdots,\theta_k\in R$</li>
<li>超几何体：$\vec{x}=\theta_1\cdot\vec{a_1}+\theta_2\cdot\vec{a_2}+\cdots+\theta_k\cdot\vec{a_k}, \ \ \theta_1+\theta_2+\cdots+\theta_k=1, \theta_1,\theta_2,\cdots,\theta_k\in [0,1]$</li>
</ul>
<hr>
<h3 id="仿射集"><a href="#仿射集" class="headerlink" title="仿射集"></a>仿射集</h3><p>以上的表示方法可以引入几何学中一个重要的概念，仿射集（Affine set）：</p>
<p> <strong>定义</strong>：通过集合$C$的任意两个不同点的直线仍在集合$C$内，则称集合$C$是仿射集</p>
<p> $$\forall x_1,x_2\in C,\forall \theta\in R, x=\theta\cdot x_1+(1-\theta)\cdot x_2\in C$$</p>
<p>仿射集的例子：</p>
<ul>
<li>直线、平面</li>
<li>超平面：$\{x|Ax=b\}$</li>
</ul>
<hr>
<h3 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h3><p>下面可以引入凸集概念，其定义有两种形式，两种形式是等价的</p>
<ul>
<li>两点定义：集合$C$内任意两点间的线段均在集合$C$内，则称集合$C$是凸集<br>$$\forall x_1,x_2\in C, \forall\theta\in[0,1], x=\theta\cdot x_1+(1-\theta)\cdot x_2\in C$$</li>
<li>$k$点定义：<br>$$\forall x_1, x_2, \cdots, x_k \in C, \forall \theta_{i}\in [0,1], \sum_{i=1}^{k}\theta_{i}=1, x=\sum_{i=1}^{k}\theta_{i} x_i \in C$$</li>
</ul>
<p>根据仿射集和凸集的定义，我们知道：仿射集一定是凸集</p>
<hr>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p><strong>定义</strong>：集合C的所有点的凸组合形成的集合，叫做集合$C$的凸包（Convex hull）</p>
<p>  $$\mathbf{conv} \ \  C =\{\sum_{i=1}^{k}\theta_{i}x_{i}|x_{i}\in C, \theta_i \geq 0, \sum_{i=1}^{k}\theta_i =1\}$$</p>
<p>推论：集合凸包是能包含$C$的最小凸集</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/convex.png" alt="convex hull"></p>
<hr>
<h3 id="超平面和半空间"><a href="#超平面和半空间" class="headerlink" title="超平面和半空间"></a>超平面和半空间</h3><ul>
<li>超平面（hyperplane）<br>$$<br>\{x\ | \ a^{T}x=b\}<br>$$<br>$a$是其法向量</li>
<li>半空间（halfspace）<br>$$<br>\{x\ | \ a^{T}x\leq b\}\quad\quad<br>\{x\ | \ a^{T}x\geq b\}<br>$$<br><img src="http://oky0w68xw.bkt.clouddn.com/hyperplane.png" alt="hyperplane"></li>
</ul>
<hr>
<h3 id="欧式球和椭球"><a href="#欧式球和椭球" class="headerlink" title="欧式球和椭球"></a>欧式球和椭球</h3><ul>
<li>欧式球<br>$$<br>B(x_c,r)=\{x \ |\ \Vert x-x_c\Vert_2 \leq r \}=\{x \ |(x-x_c)^{T}(x-x_c) \leq r^2 \}<br>$$<br>​</li>
<li>椭球<br>$$<br>E=\{x\ | (x-x_c)^T P(x-x_c)\leq r^2\}, 其中P为对称正定阵<br>$$</li>
</ul>
<hr>
<h3 id="范数球和范数锥"><a href="#范数球和范数锥" class="headerlink" title="范数球和范数锥"></a>范数球和范数锥</h3><p>我们可以将欧式空间的二范数进行推广，得到广义的范数几何体</p>
<ul>
<li>范数球（Norm Ball）<br>  $$<br>  B(x_c,r)=\{x \ |\ \Vert x-x_c\Vert \leq r \}<br>  $$</li>
<li>范数锥（Norm Cone）<br>  $$<br>  \{(x,t) \ |\ \Vert x\Vert \leq t \}<br>  $$<br><img src="http://oky0w68xw.bkt.clouddn.com/norm_cone.png" alt="Norm cone"></li>
</ul>
<hr>
<h3 id="多面体"><a href="#多面体" class="headerlink" title="多面体"></a>多面体</h3><p>引入以上概念后，我们可以如下去定义多面体（polyhedron）：</p>
<p><strong>定义</strong>：多面体是有限个半空间和超平面的交集，即<br>$$\mathcal{P}=\{ a_j^Tx\leq b_j, j=1,2,\cdots,m,\ \  c_i^T x=d_i, i=1,2,\cdots,p \}$$</p>
<ul>
<li>仿射集(如超平面、直线)、射线、线段、半空间都是多面体</li>
<li>多面体是凸集</li>
<li>有界多面体叫<em>多胞形</em>（polytope）<br><img src="http://oky0w68xw.bkt.clouddn.com/polyherdon2.png" alt="polyhedron"></li>
</ul>
<hr>
<h3 id="保凸运算"><a href="#保凸运算" class="headerlink" title="保凸运算"></a>保凸运算</h3><p>引入凸集的概念后，自然地想研究集合间的映射算子与凸集的关系，特别地是保持凸性的算子，即将凸集映射为凸集的算子，下面给出4个保凸算子（Operations that preserve convexity）</p>
<ul>
<li>集合的交运算（Intersection）<br>$$\bigcap_{\alpha\in\mathcal{A}}S_{\alpha}$$</li>
<li>仿射变换（Affine functions）$$f(x)=Ax+b$$</li>
<li><p>透视变换（Perspective functions）</p>
<p><strong>定义</strong>：$$ P:\mathbf{R}^{n+1}\rightarrow\mathbf{R}^{n}, \ \mathbf{dom} \ P=\mathbf{R}^{n}\times R_{+}$$<br>$$(x_1,x_2,\cdots,x_n,t)\rightarrow(\frac{x_1}{t},\frac{x_2}{t},\cdots,\frac{x_n}{t}), t&gt;0$$<br>从代数角度，透视变换相当于对原向量进行标准化化使得最后一个分量值为1，并去掉了最后一个分量；从几何角度，三维平面内透视变换相当于小孔成像的原理，如下图所示<br><img src="http://oky0w68xw.bkt.clouddn.com/pinhole.png" alt="pin_hole"></p>
</li>
<li><p>线性分式变换（投射变换）（Linear-fractional functions）</p>
<p><strong>定义</strong>：线性分式函数是仿射变换和透视变换的复合变换</p>
</li>
</ul>
<p>$假设仿射变换\ g:\mathbf{R}^{n}\rightarrow\mathbf{R}^{m+1}$<br>$$ g(x)=\begin{bmatrix}A\\ c^{T}\end{bmatrix}x+\begin{bmatrix}b\\ d\end{bmatrix}$$<br>$\ 其中A\in \mathbf{R}^{m\times n},b\in\mathbf{R}^{m},c\in\mathbf{R}^{n},d\in\mathbf{R}$</p>
<p>  $那么\ f:\mathbf{R}^{n}\rightarrow\mathbf{R}^{m}定义为f=P \circ g，即$<br>  $$f(x)=\frac{Ax+b}{c^Tx+d},\quad \mathbf{dom}\ f=\{x|c^Tx+d&gt;0\}$$<br>  <strong>投影理解</strong>（Projective Interpretation）:<br>  我们可以将线性分式变换写成矩阵形式，记<br>  $$Q=\left[\begin{matrix}<br>  A &amp; b\\<br>  c^T &amp; d<br>  \end{matrix}\right]\in\mathbf{R}^{(m+1)\times(n+1)}<br>  $$<br>将$\ Q\ $乘上$(x,1)$可以得到$\ Q(x,1)=(Ax+b,c^Tx+d)$，再通过对最后一个分量标准化得到$\ \left(\ f(x),1\ \right)\ $. 定义如下从$R^{n}$的元素到$R^{n+1}$中的集合的算子$$\mathcal{P}(x)=\{t\cdot(x,1)|t&gt;0\}$$，则线性分式变换$f$可以写作<br>$$f(x)=\mathcal{P}^{-1}(Q\mathcal{P}(x))$$<br>这是一个投影算子，下图给出一个例子<br><img src="http://oky0w68xw.bkt.clouddn.com/projective.png" alt="projective"></p>
<hr>
<h3 id="分割超平面"><a href="#分割超平面" class="headerlink" title="分割超平面"></a>分割超平面</h3><p><strong>定义</strong>：设$C$和$D$是两集合，若存在超平面$a^{T}x=b$使得，<br>$$\forall x\in C,a^Tx\leq b\ 且\  \forall x\in D, a^Tx\geq b$$<br>则称$\{x|a^Tx=b\}$为集合$C,D$的分割超平面（Separating hyperplane）</p>
<p><strong>定理</strong>：两个<strong>不相交的凸集</strong>必定有分割超平面<br><img src="http://oky0w68xw.bkt.clouddn.com/separate.png" alt=""></p>
<p>分割超平面的构造：两集合最近两点连线的中垂面</p>
<p>最优分割超平面的构造（SVM：Support Vector Machine）</p>
<hr>
<h3 id="支撑超平面"><a href="#支撑超平面" class="headerlink" title="支撑超平面"></a>支撑超平面</h3><p><strong>定义</strong>：设集合$C$，$x_0$为$C$边界上的点。若存在$a\neq0$, 满足对任意$x\in C$,都有$a^Tx\leq a^Tx_0$成立,则称超平面$\{x|a^Tx\leq a^Tx_0\}$为集合$C$在点$x_0$处的支撑超平面（Supporting hyperplane）</p>
<p><img src="http://oky0w68xw.bkt.clouddn.com/supporting.png" alt=""></p>
<p><strong>定理</strong>：凸集边界上任意一点，均存在支撑超平面；反之，若一个闭的非中空（内部点不为空）集合，在边界上的任意一点均存在支撑超平面，则必为凸集</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凸优化（Convex Optimization）作为机器学习中重要的数学内容，在本科阶段课程中几乎没有涉及，于是在学习机器学习的过程中，我学习了凸优化的部分内容，参考书籍为Stephen Boyd, Lieven Vandenberghe的&lt;em&gt;Convex Optimization&lt;/em&gt;，在本文主要介绍凸集等基本概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在凸优化中，凸集是重要的基本概念，为此，引入以下概念&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;直线的向量表示&quot;&gt;&lt;a href=&quot;#直线的向量表示&quot; class=&quot;headerlink&quot; title=&quot;直线的向量表示&quot;&gt;&lt;/a&gt;直线的向量表示&lt;/h3&gt;&lt;p&gt;给定二维平面上两定点：$\mathbf{a}(u_1,v_1),\mathbf{b}(u_2,v_2)$，则直线AB可以表示为&lt;br&gt;$$\vec{x}=\theta\cdot\vec{a}+(1-\theta)\cdot\vec{b},\ \theta\in R$$&lt;br&gt;若将$\theta$的范围限制到$[0,1]$，则表示线段AB&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Oliver&#39;s Notes 新开始</title>
    <link href="http://yoursite.com/2017/01/30/hello-world/"/>
    <id>http://yoursite.com/2017/01/30/hello-world/</id>
    <published>2017-01-30T07:44:16.000Z</published>
    <updated>2017-03-07T11:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>历经各种磨难，终于将自己的blog用hexo搭载好，挂在了Github上。虽然其中很多配置并不是很懂，但是也初步了解其原理：将本地的静态网站放在Github的Personal Page作为自己的blog。</p>
<p>以前在wordpress.com上建站，发现.com没有MathJax插件，写不了数学公式，加载图片也甚是麻烦，故打算关闭原来的blog，开启新的Oliver’s Notes。</p>
<p>虽然我明白这个网站并没有什么人会去看，但是希望能督促自己多读点书，多写点东西。既然想做一个Geek，就要拿出一个Geek的样子。希望未来的我能一直坚持下去，不忘初心。</p>
<p>本站记录些学习笔记，生活感悟（吐槽）等，更新频率不定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历经各种磨难，终于将自己的blog用hexo搭载好，挂在了Github上。虽然其中很多配置并不是很懂，但是也初步了解其原理：将本地的静态网站放在Github的Personal Page作为自己的blog。&lt;/p&gt;
&lt;p&gt;以前在wordpress.com上建站，发现.com没
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
